//
//  helpers.c
//  Odyssey
//
//  Created by tihmstar on 28.06.20.
//  Copyright Â© 2020 coolstar. All rights reserved.
//

#include "helpersXr.h"

#include <mach/mach.h>
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

kern_return_t mach_vm_allocate(vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);
kern_return_t mach_vm_deallocate(mach_port_name_t target, mach_vm_address_t address, mach_vm_size_t size);
#include <unistd.h>
void suspend_all_threadsXr() {
    thread_act_t other_thread, current_thread;
    unsigned int thread_count;
    thread_act_array_t thread_list;
    
    current_thread = mach_thread_self();

    //usleep(1000);

    int result = task_threads(mach_task_self(), &thread_list, &thread_count);
    if (result == -1) {
        printf("THIS IS NO GOOD!\n");
        sleep(1);
        exit(1);
    }
    if (!result && thread_count) {
       // sleep(1);
        //
        printf("Starting thread count\n");

        for (unsigned int i = 0; i < thread_count; ++i) {
            other_thread = thread_list[i];
            //usleep(100000);
            if (other_thread != current_thread) {
                usleep(200);
                printf("-");
                //sleep(1.5);
                thread_suspend(other_thread);
                //
                //sleep(1);
                printf("_");
                //
            }
        }
       // usleep(5000);
        printf("\nmach_vm_deallocate\n");
        //
        //usleep(10000);
        mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)thread_list, thread_count*sizeof(mach_port_t));
        //sleep(1);
        //usleep(1000);

        printf("mach_vm_deallocated");

    }
}

void resume_all_threadsXr() {
    thread_act_t other_thread, current_thread;
    unsigned int thread_count;
    thread_act_array_t thread_list;
    
    current_thread = mach_thread_self();
    //usleep(1000);

    int result = task_threads(mach_task_self(), &thread_list, &thread_count);
    if (result == -1) {
        sleep(2);
         exit(1);
    }
    if (!result && thread_count) {
        //usleep(100);

        for (unsigned int i = 0; i < thread_count; ++i) {
            other_thread = thread_list[i];
            //usleep(100);
            if (other_thread != current_thread) {
                //printf("usleep resume_all_threads!\n");
                usleep(1000);
                thread_resume(other_thread);
                //usleep(100);
            }
        }
        //usleep(1000);
        printf("\nresume_all_threads!\n");
        //sleep(0.3);
        mach_vm_deallocate(mach_task_self(), (mach_vm_address_t)thread_list, thread_count*sizeof(mach_port_t));
        //usleep(1000);

    }
}
