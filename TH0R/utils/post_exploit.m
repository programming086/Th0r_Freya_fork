//
//  post_exploit.c
//  ios-fuzzer
//
//  Created by Quote on 2021/1/28.
//  Copyright © 2021 Quote. All rights reserved.
//

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <mach/mach.h>
#include <copyfile.h>
#include <spawn.h>
#include <Foundation/Foundation.h>
#include "../headers/common.h"
#include "utilsZS.h"
#include "KernelUtils.h"
#include "../lib/kernel_call/OffsetHolder.h"
#include "../lib/amfi/amfi.h"
#include "../lib/PFinder64/patchfinder64.h"
#include "../lib/amfi/amfi_utils.h"
#include "../lib/remap_tfp_set_hsp/remap_tfp_set_hsp.h"

#define copyfile(X,Y) (copyfile)(X, Y, 0, COPYFILE_ALL|COPYFILE_RECURSIVE|COPYFILE_NOFOLLOW_SRC);
#define JAILB_ROOT "/private/var/containers/Bundle/jb_resources/"
#define in_bundle(obj) strdup([[[[NSBundle mainBundle] bundlePath] stringByAppendingPathComponent:@obj] UTF8String])
#define failIf(condition, message, ...) if (condition) {\
}
static const char *jailb_root = JAILB_ROOT;

char *Build_resource_path(char *filename);
void patch_amfid(pid_t amfid_pid);
#include <ifaddrs.h>
#include <net/if.h>
#include <arpa/inet.h>
#include <copyfile.h>
#include <dirent.h>


#define PROC_ALL_PIDS        1
char *Build_resource_path(char *filename)
{
    NSString *resourcePath = [[NSBundle mainBundle] resourcePath];
    if(filename == NULL) {
        return strdup([[resourcePath stringByAppendingString:@"/"] UTF8String]);
    }
    return strdup([[resourcePath stringByAppendingPathComponent:[NSString stringWithUTF8String:filename]] UTF8String]);
}

extern int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize);
extern int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);








struct proc_cred {
    char posix_cred[0x100]; // HACK big enough
    kptr_t cr_label;
    kptr_t sandbox_slot;
};



void proc_restore_cred(kptr_t proc, struct proc_cred *old_cred)
{
    // TODO
}

void display_ip_address(){
    struct ifaddrs *interfaces = NULL;
    struct ifaddrs *temp_addr = NULL;
    if(getifaddrs(&interfaces) == 0){
        temp_addr = interfaces;
        while(temp_addr != NULL) {
            if(temp_addr->ifa_addr->sa_family == AF_INET) {
                
                util_info("    %s: ", temp_addr->ifa_name);
                char *ip_addr = inet_ntoa(((struct sockaddr_in *)temp_addr->ifa_addr)->sin_addr);
                util_info("    %s", ip_addr);
            }
            temp_addr = temp_addr->ifa_next;
        }
        freeifaddrs(interfaces);
    }else{
        util_error("Error: getifaddrs");
    }
}
void check_file_type_and_give_em_permission(char *file_path){
    uint32_t HeaderMagic32 = 0xFEEDFACE; // MH_MAGIC
    uint32_t HeaderMagic32Swapped = 0xCEFAEDFE; // MH_CIGAM
    uint32_t HeaderMagic64 = 0xFEEDFACF; // MH_MAGIC_64
    uint32_t HeaderMagic64Swapped = 0xCFFAEDFE; // MH_CIGAM_64
    uint32_t UniversalMagic = 0xCAFEBABE; // FAT_MAGIC
    uint32_t UniversalMagicSwapped = 0xBEBAFECA; // FAT_CIGAM
    
    struct stat fstat = {0};
    if(stat(file_path, &fstat)){
        return;
    }
    if(fstat.st_size < (20))
        return;
    
    int fd = open(file_path, O_RDONLY);
    if(fd){
        uint32_t *file_head4bytes = mmap(NULL, PAGE_SIZE, PROT_READ, MAP_SHARED, fd, 0);
        if((int)(file_head4bytes) == -1){
            close(fd);
            return;
        }
        if((*file_head4bytes == HeaderMagic32) ||
           (*file_head4bytes == HeaderMagic32Swapped) ||
           (*file_head4bytes == HeaderMagic64) ||
           (*file_head4bytes == HeaderMagic64Swapped) ||
           (*file_head4bytes == UniversalMagic) ||
           (*file_head4bytes == UniversalMagicSwapped) ||
           !strncmp((char*)file_head4bytes, "#!", 2)
           ){
            chown(file_path, 0, 0);
            chmod(file_path, 0755);
        }
        munmap(file_head4bytes, PAGE_SIZE);
        close(fd);
    }
}

void alter_exec_perm_in_dir(const char *name, int i_deep){
    DIR *dir;
    struct dirent *entry;
    
    if (!(dir = opendir(name))){
        return;
    }
    
    while ((entry = readdir(dir)) != NULL) {
        if (entry->d_type == DT_DIR) {
            char path[1024];
            if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
                continue;
            if(entry->d_name[0] == '.')
                continue;
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);
            
            alter_exec_perm_in_dir(path, i_deep+1);
        } else {
            char path[1024];
            snprintf(path, sizeof(path), "%s/%s", name, entry->d_name);
            
            check_file_type_and_give_em_permission(path);
        }
    }
    closedir(dir);
}
#pragma mark ---- Post-exp main entry ----
extern char**environ;

static int runCommandv(const char *cmd, int argc, const char * const* argv, void (^unrestrict)(pid_t))
{
    pid_t pid;
    posix_spawn_file_actions_t *actions = NULL;
    posix_spawn_file_actions_t actionsStruct;
    int out_pipe[2];
    bool valid_pipe = false;
    posix_spawnattr_t *attr = NULL;
    posix_spawnattr_t attrStruct;

    valid_pipe = pipe(out_pipe) == 0;
    if (valid_pipe && posix_spawn_file_actions_init(&actionsStruct) == 0) {
        actions = &actionsStruct;
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 1);
        posix_spawn_file_actions_adddup2(actions, out_pipe[1], 2);
        posix_spawn_file_actions_addclose(actions, out_pipe[0]);
        posix_spawn_file_actions_addclose(actions, out_pipe[1]);
    }

    if (unrestrict && posix_spawnattr_init(&attrStruct) == 0) {
        attr = &attrStruct;
        posix_spawnattr_setflags(attr, POSIX_SPAWN_START_SUSPENDED);
    }

    int rv = posix_spawn(&pid, cmd, actions, attr, (char *const *)argv, environ);

    if (unrestrict) {
        unrestrict(pid);
        kill(pid, SIGCONT);
    }

    if (valid_pipe) {
        close(out_pipe[1]);
    }

    if (rv == 0) {
        if (valid_pipe) {
            char buf[256];
            ssize_t len;
            while (1) {
                len = read(out_pipe[0], buf, sizeof(buf) - 1);
                if (len == 0) {
                    break;
                }
                else if (len == -1) {
                    perror("posix_spawn, read pipe");
                }
                buf[len] = 0;
                util_printf("%s", buf);
            }
        }
        if (waitpid(pid, &rv, 0) == -1) {
            util_error("ERROR: Waitpid failed");
        } else {
            util_info("%s(%d) completed with exit status %d", __FUNCTION__, pid, WEXITSTATUS(rv));
        }

    } else {
        util_error("%s(%d): ERROR posix_spawn failed (%d): %s", __FUNCTION__, pid, rv, strerror(rv));
        rv <<= 8; // Put error into WEXITSTATUS
    }
    if (valid_pipe) {
        close(out_pipe[0]);
    }
    return rv;
}

int util_runCommand(const char *cmd, ...)
{
    va_list ap, ap2;
    int argc = 1;

    va_start(ap, cmd);
    va_copy(ap2, ap);

    while (va_arg(ap, const char *) != NULL) {
        argc++;
    }
    va_end(ap);

    const char *argv[argc+1];
    argv[0] = cmd;
    for (int i=1; i<argc; i++) {
        argv[i] = va_arg(ap2, const char *);
    }
    va_end(ap2);
    argv[argc] = NULL;

    int rv = runCommandv(cmd, argc, argv, NULL);
    return WEXITSTATUS(rv);
}



void post_exploit(void)
{
    // can not do this under PAC
    //kapi_write64(g_exp.self_proc + OFFSET(proc, p_ucred), kernelCredAddr);

    uint32_t uid = getuid();
    util_printf("getuid() returns %u\n", uid);
    util_printf("whoami: %s\n", uid == 0 ? "root" : "mobile");
    setgid(0);
    uint32_t gid = getgid();
    util_printf("getgid() returns %u\n", gid);
    int err = setuid(0);
    if (err) {
        perror("setuid");
    }

    // Test writing to the outer worlds
    util_info("---- Sandbox ----");
    if (1) { // ok
        FILE *fp = fopen("/var/mobile/.LiRa", "wb");
        fail_if(fp == NULL, "không viết được /var/mobile/.LiRa");
        util_info("đã viết tệp thử nghiệm: %p", fp);
        fprintf(fp, "LiRam Team jailbreak\n");
        fclose(fp);
    }
    util_info("Đã thoát khỏi Sandbox");
    util_info("---- Xong ----\n");
    //patch_TF_PLATFORM(g_exp.self_task);

    // ----------------------------------------------------------------------
    util_info("---- Set HSP4----");
    
   
    util_info("---- Xong ----\n");
    //  Stage 1. Make executable
    util_info("---- AMFID ----");
    platformize_amfi(getpid());
    grabEntitlements(get_proc_struct_for_pid(getpid()));
    takeoverAmfid(pidOfProcess("amfid"));
        const char *amfid_bypassd_path = "/private/var/containers/Bundle/jb_resources/amfid_bypassd";
        if(look_for_proc(amfid_bypassd_path)){
            util_info("amfid_bypassd already running\n");
            return;
        }
        remove(amfid_bypassd_path);unlink(amfid_bypassd_path);
        if(access(amfid_bypassd_path, F_OK)){
            mkdir("/private/var/containers/Bundle/jb_resources", 0777);
            copyfile(Build_resource_path("/jb_resources/amfid_bypassd"), amfid_bypassd_path);
            chown(amfid_bypassd_path, 0, 0);
            chmod(amfid_bypassd_path, 0755);
        }
        pid_t amfid_bypassd_pid = 0;
        if(fork() == 0){
            daemon(1, 1);
            close(STDIN_FILENO);
            close(STDOUT_FILENO);
            close(STDERR_FILENO);
            const char *argv[] = {amfid_bypassd_path, NULL};
            execvp(argv[0], (char*const*)argv);
            exit(1);
        }
    util_info("---- Xong ----\n");
    
    //  bootstrap rootfs
    [[NSFileManager defaultManager] copyItemAtPath:[NSString stringWithUTF8String:in_bundle("rootfs")] toPath:@"/tmp/rootfs" error:nil];
    chmod("/tmp/rootfs", 0755);
    //  Stage 2. Remount RootFS
    util_info("---- Remount/RootFS ----");
   

    FILE *f = fopen("/.remount_success", "w");
    fprintf(f,"Công cụ thuộc LiRa Team\n");
    fclose(f);

    if(access("/.remount_success", F_OK) == -1) {
        util_info("Không thể ghi tệp trên rootfs.");
       // goto err;
    }
    util_info("Ghi thành công tệp trên rootfs.");
    unlink("/.remount_success");

    /*  Stage 2-2. Restore RootFS
    if(!restore_rootfs())
    {
        util_error("Failed to restore rootfs!\n");
        goto err;
    }    */
    util_info("---- Xong ----\n");
    //Stage 3 bootstrap
    util_info("---- Đang cài đặt Bootstrap ----");
    copyfile(Build_resource_path("/jb_resources/binpack64/bin"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/bin", 0); util_info("(1/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/etc"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/etc", 0); util_info("(2/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/sbin"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/sbin", 0);
    util_info("(3/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/usr"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/usr", 0); util_info("(4/5)...");
    copyfile(Build_resource_path("/jb_resources/binpack64/var"), "/private/var/containers/Bundle/jb_resources/"); alter_exec_perm_in_dir("/private/var/containers/Bundle/jb_resources/var", 0); util_info("(5/5)...");
    copyfile(Build_resource_path("/jb_resources/fix_14_0.sh"), "/private/var/containers/Bundle/jb_resources/");
    copyfile(Build_resource_path("/jb_resources/share_analytics.sh"), "/private/var/containers/Bundle/jb_resources/");
    
    chown("/private/var/containers/Bundle/jb_resources/share_analytics.sh", 0, 0);
    chmod("/private/var/containers/Bundle/jb_resources/share_analytics.sh", 0755);
    
    // Bật SSH và set port
    setenv("DYLD_LIBRARY_PATH", "/private/var/containers/Bundle/jb_resources/usr/lib", 1);
    setenv("PATH2", "/private/var/containers/Bundle/jb_resources/bin:/private/var/containers/Bundle/jb_resources/sbin:/private/var/containers/Bundle/jb_resources/usr/bin:/private/var/containers/Bundle/jb_resources/usr/sbin", 1);
    chdir("/private/var/containers/Bundle/jb_resources");
    
    util_runCommand("/private/var/containers/Bundle/jb_resources/bin/bash", "-c", "/private/var/containers/Bundle/jb_resources/usr/bin/nohup /private/var/containers/Bundle/jb_resources/usr/sbin/sshd -D -p 9999 -f \"/private/var/containers/Bundle/jb_resources/etc/ssh/sshd_config\" >/dev/null 2>&1 &", NULL);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bash", 0755);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bin/sw_vers", 0755);
    chmod("/private/var/containers/Bundle/jb_resources/usr/bin/uname", 0755);
    util_info("---- Xong ----\n");
    util_info("---- Cổng/iP ----");
    util_info("Cổng: 9999");
        display_ip_address();
    util_info("---- Xong ----\n");
    
    util_info("---- Jailbreak thành công:) ----");
    
    // ----------------------------------------------------------------------


}
